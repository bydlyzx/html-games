<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雷电风纵向射击网页小游戏 | Thunder Shooter - Arcade Vertical Shooter</title>
    <meta name="description" content="雷电风纵向卷轴射击网页小游戏（纯原生 HTML+Canvas）：鼠标平滑操控、自动连射、火力升级、Boss 战与爆炸特效。Thunder Shooter is a fast-paced Raiden-style vertical scrolling shooter playable in the browser with mouse control, auto-fire, power-ups, sub-weapons, and boss fights.">
    <meta name="keywords" content="雷电,纵向射击,街机射击,弹幕,网页游戏,Canvas,JavaScript,HTML5,Power Up,Boss,vertical shooter,arcade shooter,shoot 'em up,Raiden style,Canvas game">
    <meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta name="theme-color" content="#000011">
    <meta name="color-scheme" content="dark">
    <meta name="format-detection" content="telephone=no">

    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Thunder Shooter">
    <meta property="og:title" content="雷电风纵向射击网页小游戏 | Thunder Shooter">
    <meta property="og:description" content="雷电风纵向卷轴射击网页小游戏：鼠标操控、自动连射、火力升级与 Boss 战。Raiden-style vertical shooter playable in the browser with power-ups, sub-weapons, and boss fights.">
    <meta property="og:locale" content="zh_CN">
    <meta property="og:locale:alternate" content="en_US">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Thunder Shooter - 雷电风纵向射击">
    <meta name="twitter:description" content="Raiden-style vertical shooter in one HTML file: mouse control, auto-fire, power-ups, and boss fights. 雷电风纵向射击网页小游戏：火力升级、特效爆炸、Boss 战。">

    <script type="application/ld+json">{"@context":"https://schema.org","@type":"VideoGame","name":"Thunder Shooter","alternateName":"雷电风纵向射击","description":"雷电风纵向卷轴射击网页小游戏（纯原生 HTML+Canvas）：鼠标平滑操控、自动连射、火力升级、Boss 战与爆炸特效。Thunder Shooter is a fast-paced Raiden-style vertical scrolling shooter playable in the browser with mouse control, auto-fire, power-ups, sub-weapons, and boss fights.","genre":["Vertical shooter","Shoot 'em up","Arcade"],"gamePlatform":"Web Browser","inLanguage":["zh-CN","en"],"operatingSystem":"Any","applicationCategory":"GameApplication","offers":{"@type":"Offer","price":"0","priceCurrency":"USD"}}</script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent mobile scrolling */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 20px;
            text-shadow: 0 0 5px #0ff;
        }
        .hud-bottom {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }
        .bar-container {
            width: 200px;
            height: 10px;
            background: #333;
            border: 1px solid #555;
            margin-top: 5px;
        }
        .hp-bar {
            width: 100%;
            height: 100%;
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
            transition: width 0.2s;
        }
        .boss-hp-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 15px;
            background: #300;
            border: 2px solid #f00;
            display: none; /* Hidden by default */
        }
        .boss-hp-bar {
            width: 100%;
            height: 100%;
            background: #f00;
            box-shadow: 0 0 10px #f00;
            transition: width 0.1s;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }
        h1 {
            font-size: 60px;
            color: #ff0;
            text-shadow: 0 0 20px #f00;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 5px;
            font-style: italic;
        }
        button {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(to bottom, #4a90e2, #003366);
            color: white;
            border: 2px solid #88ccff;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 0 15px #0088ff;
            transition: transform 0.1s, box-shadow 0.1s;
            text-transform: uppercase;
            font-weight: bold;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px #00aaff;
        }
        button:active {
            transform: scale(0.95);
        }
        .hidden {
            display: none !important;
        }
        .controls-hint {
            margin-top: 20px;
            color: #aaa;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div>SCORE: <span id="score-display">0</span></div>
            <div>HIGHSCORE: <span id="highscore-display">0</span></div>
        </div>
        
        <div class="boss-hp-container" id="boss-hp-container">
            <div class="boss-hp-bar" id="boss-hp-bar"></div>
        </div>

        <div class="hud-bottom">
            <div>
                <div>SHIELD</div>
                <div class="bar-container"><div class="hp-bar" id="hp-bar"></div></div>
                <div style="margin-top: 5px; color: #ff0;">BOMBS: <span id="bomb-display">3</span></div>
            </div>
            <div style="text-align: right;">
                <div style="color: #0ff;">WEAPON LV: <span id="weapon-lv-display">1</span></div>
                <div style="color: #f0f;">SUB: <span id="sub-weapon-display">NONE</span></div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>THUNDER STRIKE</h1>
        <button id="start-btn">START MISSION</button>
        <div class="controls-hint">Mouse to Move • Click to Bomb</div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #f33;">MISSION FAILED</h1>
        <div style="font-size: 30px; margin-bottom: 30px;">FINAL SCORE: <span id="final-score">0</span></div>
        <button id="restart-btn">RETRY</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- AUDIO SYSTEM (Web Audio API) ---
        const AudioSys = {
            ctx: null,
            noiseBuffer: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                // Pre-generate noise buffer
                const bufferSize = this.ctx.sampleRate * 2.0; // 2 seconds
                this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = this.noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playExplosion: function(scale = 1) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                // 1. Noise Burst (The "Crack")
                const noiseSrc = this.ctx.createBufferSource();
                noiseSrc.buffer = this.noiseBuffer;
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(800, t);
                noiseFilter.frequency.exponentialRampToValueAtTime(100, t + 0.4 * scale);
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.8 * scale, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4 * scale);
                noiseSrc.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                noiseSrc.start();

                // 2. Low Frequency Impact (The "Thump")
                const osc = this.ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(120, t);
                osc.frequency.exponentialRampToValueAtTime(20, t + 0.6 * scale);
                const oscGain = this.ctx.createGain();
                oscGain.gain.setValueAtTime(1.0 * scale, t);
                oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.6 * scale);
                osc.connect(oscGain);
                oscGain.connect(this.ctx.destination);
                osc.start();
            },
            playShoot: function() { this.playTone(600, 'square', 0.05, 0.03); }, // Sharper shot
            playEnemyExplosion: function() { this.playExplosion(0.5); },
            playPlayerExplosion: function() { this.playExplosion(1.5); },
            playBossExplosion: function() { this.playExplosion(3.0); },
            playPowerUp: function() { 
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, t);
                osc.frequency.linearRampToValueAtTime(1800, t + 0.1);
                osc.frequency.linearRampToValueAtTime(800, t + 0.3); // Arpeggio-ish
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.3);
            },
            playBomb: function() {
                if (!this.ctx) return;
                this.playExplosion(2.5);
                // Extra Rumble
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 2.0);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 2.0);
            }
        };

        // --- GAME CONSTANTS ---
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');
        
        const COLORS = {
            player: '#00ccff',
            enemy: '#ff3333',
            bulletPlayer: '#ffff00',
            bulletEnemy: '#ff9999',
            bg: '#000011',
            star: '#ffffff'
        };

        const STATE = {
            MENU: 0,
            PLAYING: 1,
            GAMEOVER: 2
        };

        // --- GAME ENGINE ---
        class Game {
            constructor() {
                this.state = STATE.MENU;
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.resize();
                
                this.player = null;
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.items = [];
                this.stars = [];
                this.boss = null;
                
                this.score = 0;
                this.highScore = localStorage.getItem('thunder_highscore') || 0;
                this.frameCount = 0;
                this.difficulty = 1;
                
                this.cameraShake = 0;

                // Bind inputs
                window.addEventListener('resize', () => this.resize());
                window.addEventListener('mousemove', (e) => this.handleInput(e));
                window.addEventListener('mousedown', () => this.handleClick());
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === STATE.PLAYING) this.player.useBomb();
                });

                // UI Elements
                this.uiScore = document.getElementById('score-display');
                this.uiHigh = document.getElementById('highscore-display');
                this.uiHp = document.getElementById('hp-bar');
                this.uiBomb = document.getElementById('bomb-display');
                this.uiWepLv = document.getElementById('weapon-lv-display');
                this.uiSub = document.getElementById('sub-weapon-display');
                this.uiBossHpContainer = document.getElementById('boss-hp-container');
                this.uiBossHp = document.getElementById('boss-hp-bar');
                
                this.screenStart = document.getElementById('start-screen');
                this.screenOver = document.getElementById('game-over-screen');
                
                document.getElementById('start-btn').onclick = () => this.start();
                document.getElementById('restart-btn').onclick = () => this.start();
                document.getElementById('final-score').innerText = '0';
                this.uiHigh.innerText = this.highScore;

                this.initStars();
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                CANVAS.width = this.width;
                CANVAS.height = this.height;
            }

            initStars() {
                this.stars = [];
                for(let i=0; i<150; i++) {
                    this.stars.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        size: Math.random() * 2 + 0.5,
                        speed: Math.random() * 3 + 0.5
                    });
                }
            }

            start() {
                AudioSys.init();
                this.state = STATE.PLAYING;
                this.score = 0;
                this.difficulty = 1;
                this.frameCount = 0;
                
                this.player = new Player(this.width/2, this.height - 100);
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.items = [];
                this.boss = null;

                this.screenStart.classList.add('hidden');
                this.screenOver.classList.add('hidden');
                this.uiBossHpContainer.style.display = 'none';
                
                this.updateUI();
            }

            handleInput(e) {
                if (this.state !== STATE.PLAYING || !this.player) return;
                // Smooth follow handled in Player update, just update target here
                this.player.targetX = e.clientX;
                this.player.targetY = e.clientY;
            }

            handleClick() {
                if (this.state === STATE.PLAYING && this.player) {
                    this.player.useBomb();
                }
            }

            gameOver() {
                this.state = STATE.GAMEOVER;
                this.screenOver.classList.remove('hidden');
                document.getElementById('final-score').innerText = Math.floor(this.score);
                if (this.score > this.highScore) {
                    this.highScore = Math.floor(this.score);
                    localStorage.setItem('thunder_highscore', this.highScore);
                    this.uiHigh.innerText = this.highScore;
                }
            }

            addScore(points) {
                this.score += points;
                this.updateUI();
            }

            updateUI() {
                this.uiScore.innerText = Math.floor(this.score);
                if (this.player) {
                    const hpPercent = (this.player.hp / this.player.maxHp) * 100;
                    this.uiHp.style.width = `${Math.max(0, hpPercent)}%`;
                    this.uiBomb.innerText = this.player.bombs;
                    this.uiWepLv.innerText = this.player.weaponLevel;
                    this.uiSub.innerText = this.player.subWeapon || "NONE";
                }
            }

            shake(amount) {
                this.cameraShake = amount;
            }

            spawnEnemy() {
                // Spawn logic based on difficulty
                const spawnRate = Math.max(20, 60 - this.difficulty * 2);
                if (this.frameCount % Math.floor(spawnRate) === 0) {
                    const x = Math.random() * (this.width - 40) + 20;
                    // Types: 0: Drone (easy), 1: Shooter (med), 2: Dasher (hard)
                    let type = 0;
                    if (this.difficulty > 2 && Math.random() < 0.3) type = 1;
                    if (this.difficulty > 5 && Math.random() < 0.1) type = 2;
                    
                    this.enemies.push(new Enemy(x, -50, type));
                }

                // Boss spawn every 2000 score or so
                if (!this.boss && this.score > 0 && this.score % 3000 < 100 && this.score > 2000 * this.difficulty) {
                    // Simple check to prevent multi-boss
                    if (this.enemies.filter(e => e.isBoss).length === 0) {
                        this.boss = new Boss(this.width/2, -200, this.difficulty);
                        this.enemies.push(this.boss);
                        this.uiBossHpContainer.style.display = 'block';
                    }
                }
            }

            loop() {
                // Update
                if (this.state === STATE.PLAYING) {
                    this.frameCount++;
                    if (this.frameCount % 600 === 0) this.difficulty += 0.5;

                    this.spawnEnemy();

                    // Background
                    this.stars.forEach(s => {
                        s.y += s.speed + (this.difficulty * 0.5);
                        if (s.y > this.height) {
                            s.y = 0;
                            s.x = Math.random() * this.width;
                        }
                    });

                    // Player
                    this.player.update();

                    // Entities
                    this.enemies.forEach(e => e.update());
                    this.bullets.forEach(b => b.update());
                    this.items.forEach(i => i.update());
                    this.particles.forEach(p => p.update());

                    // Cleanup
                    this.enemies = this.enemies.filter(e => !e.markedForDeletion);
                    this.bullets = this.bullets.filter(b => !b.markedForDeletion);
                    this.items = this.items.filter(i => !i.markedForDeletion);
                    this.particles = this.particles.filter(p => !p.markedForDeletion);
                    
                    if (this.boss && this.boss.markedForDeletion) {
                        this.boss = null;
                        this.uiBossHpContainer.style.display = 'none';
                        this.difficulty += 1; // Boss defeat spikes difficulty
                    }

                    // Collisions
                    this.checkCollisions();
                    
                    // Camera Shake decay
                    if (this.cameraShake > 0) this.cameraShake *= 0.9;
                    if (this.cameraShake < 0.5) this.cameraShake = 0;

                    this.updateUI();
                }

                // Draw
                CTX.fillStyle = COLORS.bg;
                CTX.fillRect(0, 0, this.width, this.height);

                CTX.save();
                if (this.cameraShake > 0) {
                    const dx = (Math.random() - 0.5) * this.cameraShake;
                    const dy = (Math.random() - 0.5) * this.cameraShake;
                    CTX.translate(dx, dy);
                }

                // Stars
                CTX.fillStyle = COLORS.star;
                this.stars.forEach(s => {
                    CTX.globalAlpha = Math.random() * 0.5 + 0.5;
                    CTX.beginPath();
                    CTX.arc(s.x, s.y, s.size, 0, Math.PI*2);
                    CTX.fill();
                });
                CTX.globalAlpha = 1;

                // Game Objects
                this.items.forEach(i => i.draw());
                this.particles.forEach(p => p.draw());
                this.enemies.forEach(e => e.draw());
                if (this.player && this.state === STATE.PLAYING) this.player.draw();
                this.bullets.forEach(b => b.draw());

                CTX.restore();

                requestAnimationFrame(this.loop);
            }

            checkCollisions() {
                // Player vs Enemy
                this.enemies.forEach(enemy => {
                    if (this.checkCircleCollision(this.player, enemy)) {
                        if (!this.player.invulnerable && !enemy.isBoss) {
                            this.player.hit(20);
                            enemy.hit(100); // Crash kills small enemies
                            this.shake(10);
                            AudioSys.playPlayerExplosion();
                        } else if (enemy.isBoss && !this.player.invulnerable) {
                             this.player.hit(1); // Continuous damage touching boss
                        }
                    }
                });

                // Bullets
                this.bullets.forEach(bullet => {
                    if (bullet.isPlayer) {
                        this.enemies.forEach(enemy => {
                            if (this.checkCircleCollision(bullet, enemy)) {
                                enemy.hit(bullet.damage);
                                bullet.markedForDeletion = true;
                                this.createParticles(bullet.x, bullet.y, 2, '#ff0');
                            }
                        });
                    } else {
                        // Enemy bullet vs Player
                        if (this.checkCircleCollision(bullet, this.player)) {
                            if (!this.player.invulnerable) {
                                this.player.hit(bullet.damage);
                                bullet.markedForDeletion = true;
                                this.shake(5);
                            }
                        }
                    }
                });

                // Items
                this.items.forEach(item => {
                    if (this.checkCircleCollision(item, this.player)) {
                        this.player.collectItem(item);
                        item.markedForDeletion = true;
                        AudioSys.playPowerUp();
                        this.addScore(500);
                    }
                });
            }

            checkCircleCollision(c1, c2) {
                const dx = c1.x - c2.x;
                const dy = c1.y - c2.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                return dist < (c1.radius + c2.radius);
            }

            createParticles(x, y, count, color, speed = 1) {
                for(let i=0; i<count; i++) {
                    this.particles.push(new Particle(x, y, color, speed));
                }
            }
            
            createExplosion(x, y, scale = 1) {
                this.createParticles(x, y, 10 * scale, '#f50', 3);
                this.createParticles(x, y, 5 * scale, '#ff0', 2);
                this.shake(5 * scale);
                AudioSys.playEnemyExplosion();
            }
        }

        // --- ENTITIES ---
        
        class Entity {
            constructor(x, y, r) {
                this.x = x;
                this.y = y;
                this.radius = r;
                this.markedForDeletion = false;
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 10);
                this.targetX = x;
                this.targetY = y;
                this.maxHp = 100;
                this.hp = this.maxHp;
                this.speed = 0.15; // Smooth factor
                this.weaponLevel = 1;
                this.maxWeaponLevel = 5;
                this.subWeapon = null; // 'HOMING', 'LASER'
                this.subWeaponLevel = 1;
                this.bombs = 3;
                
                this.invulnerable = false;
                this.invulnerableTimer = 0;
                
                this.lastShot = 0;
                this.fireRate = 5; // Frames (Super fast fire rate)
                
                // Visuals
                this.width = 30;
                this.height = 40;
            }

            update() {
                // Smooth movement
                this.x += (this.targetX - this.x) * this.speed;
                this.y += (this.targetY - this.y) * this.speed;
                
                // Boundaries
                this.x = Math.max(this.radius, Math.min(game.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(game.height - this.radius, this.y));

                // Shooting
                if (game.frameCount - this.lastShot > this.fireRate) {
                    this.shoot();
                    this.lastShot = game.frameCount;
                }

                // Invulnerability
                if (this.invulnerable) {
                    this.invulnerableTimer--;
                    if (this.invulnerableTimer <= 0) this.invulnerable = false;
                }
            }

            draw() {
                if (this.invulnerable && Math.floor(Date.now() / 50) % 2 === 0) return;

                CTX.save();
                CTX.translate(this.x, this.y);
                
                // Engine glow
                CTX.shadowBlur = 15;
                CTX.shadowColor = '#0ff';
                
                // Ship body
                CTX.fillStyle = '#ccc';
                CTX.beginPath();
                CTX.moveTo(0, -20);
                CTX.lineTo(15, 15);
                CTX.lineTo(0, 10);
                CTX.lineTo(-15, 15);
                CTX.closePath();
                CTX.fill();

                // Cockpit
                CTX.fillStyle = '#f00';
                CTX.beginPath();
                CTX.moveTo(0, -5);
                CTX.lineTo(3, 5);
                CTX.lineTo(-3, 5);
                CTX.fill();

                // Wings
                if (this.weaponLevel > 2) {
                    CTX.fillStyle = '#888';
                    CTX.beginPath();
                    CTX.moveTo(15, 5);
                    CTX.lineTo(25, 15);
                    CTX.lineTo(15, 15);
                    CTX.fill();
                    CTX.beginPath();
                    CTX.moveTo(-15, 5);
                    CTX.lineTo(-25, 15);
                    CTX.lineTo(-15, 15);
                    CTX.fill();
                }

                CTX.restore();
                
                // Subweapons visuals (Wingmen)
                if (this.subWeapon) {
                    const offset = 30;
                    this.drawWingman(-offset, 10);
                    this.drawWingman(offset, 10);
                }
            }

            drawWingman(ox, oy) {
                CTX.save();
                CTX.translate(this.x + ox, this.y + oy);
                CTX.fillStyle = this.subWeapon === 'LASER' ? '#00f' : '#f0f';
                CTX.shadowBlur = 5;
                CTX.shadowColor = CTX.fillStyle;
                CTX.beginPath();
                CTX.arc(0, 0, 5, 0, Math.PI*2);
                CTX.fill();
                CTX.restore();
            }

            shoot() {
                AudioSys.playShoot();
                
                // Main Gun Logic
                // Buffed Damage: Base 20 + 5 per level (Lv1: 25, Lv5: 45)
                let damage = 20 + this.weaponLevel * 5;
                let speed = 20; // Faster bullets
                
                // Center shot (always present)
                game.bullets.push(new Bullet(this.x, this.y - 20, 0, -speed, true, damage));

                // Upgrades
                if (this.weaponLevel >= 2) {
                    game.bullets.push(new Bullet(this.x - 10, this.y - 10, 0, -speed, true, damage));
                    game.bullets.push(new Bullet(this.x + 10, this.y - 10, 0, -speed, true, damage));
                }
                if (this.weaponLevel >= 3) {
                    // Angled
                    game.bullets.push(new Bullet(this.x, this.y - 10, -3, -speed * 0.9, true, damage));
                    game.bullets.push(new Bullet(this.x, this.y - 10, 3, -speed * 0.9, true, damage));
                }
                if (this.weaponLevel >= 4) {
                    // More spread
                    game.bullets.push(new Bullet(this.x, this.y - 10, -6, -speed * 0.8, true, damage));
                    game.bullets.push(new Bullet(this.x, this.y - 10, 6, -speed * 0.8, true, damage));
                }
                if (this.weaponLevel === 5) {
                    // Max power - extra thick center stream (simulated by extra bullets)
                    game.bullets.push(new Bullet(this.x - 5, this.y - 20, 0, -speed, true, damage));
                    game.bullets.push(new Bullet(this.x + 5, this.y - 20, 0, -speed, true, damage));
                }

                // Subweapons
                if (this.subWeapon === 'HOMING') {
                    if (game.frameCount % 15 === 0) { 
                        game.bullets.push(new Bullet(this.x - 30, this.y, -5, -5, true, 30, 'HOMING'));
                        game.bullets.push(new Bullet(this.x + 30, this.y, 5, -5, true, 30, 'HOMING'));
                    }
                } else if (this.subWeapon === 'LASER') {
                     if (game.frameCount % 5 === 0) {
                        game.bullets.push(new Bullet(this.x - 25, this.y, 0, -25, true, 8, 'LASER'));
                        game.bullets.push(new Bullet(this.x + 25, this.y, 0, -25, true, 8, 'LASER'));
                     }
                } else if (this.subWeapon === 'SPREAD') {
                    if (game.frameCount % 10 === 0) {
                        for(let i=-2; i<=2; i++) {
                            game.bullets.push(new Bullet(this.x, this.y, i*5, -15, true, 20));
                        }
                    }
                } else if (this.subWeapon === 'PLASMA') {
                    if (game.frameCount % 40 === 0) { // Slow fire
                        game.bullets.push(new Bullet(this.x, this.y - 20, 0, -8, true, 100, 'PLASMA')); // High damage
                    }
                } else if (this.subWeapon === 'VULCAN') {
                    // Extra stream
                    game.bullets.push(new Bullet(this.x - 15, this.y, -2, -22, true, 15));
                    game.bullets.push(new Bullet(this.x + 15, this.y, 2, -22, true, 15));
                }
            }

            hit(dmg) {
                if (this.invulnerable) return;
                this.hp -= dmg;
                this.invulnerable = true;
                this.invulnerableTimer = 60; // 1 sec
                game.shake(10);
                game.updateUI();
                
                if (this.hp <= 0) {
                    game.createExplosion(this.x, this.y, 3);
                    game.gameOver();
                }
            }

            collectItem(item) {
                switch(item.type) {
                    case 'PWR_S':
                        if (this.weaponLevel < this.maxWeaponLevel) this.weaponLevel++;
                        else this.score += 1000;
                        break;
                    case 'PWR_MAX':
                        this.weaponLevel = this.maxWeaponLevel;
                        break;
                    case 'BOMB':
                        this.bombs++;
                        break;
                    case 'LIFE_S':
                        this.hp = Math.min(this.hp + 30, this.maxHp);
                        break;
                    case 'LIFE_MAX':
                        this.hp = this.maxHp;
                        break;
                    case 'W_HOMING': this.subWeapon = 'HOMING'; break;
                    case 'W_LASER': this.subWeapon = 'LASER'; break;
                    case 'W_SPREAD': this.subWeapon = 'SPREAD'; break;
                    case 'W_PLASMA': this.subWeapon = 'PLASMA'; break;
                    case 'W_VULCAN': this.subWeapon = 'VULCAN'; break;
                    
                    case 'SHIELD':
                        this.hp = Math.min(this.hp + 50, this.maxHp + 50); // Overheal
                        break;
                    case 'TIME_STOP':
                        game.enemies.forEach(e => e.frozen = 120); // 2 sec
                        break;
                    case 'CLEAR_W':
                        game.bullets = game.bullets.filter(b => b.isPlayer);
                        break;
                    case 'SPD_UP':
                        this.speed = Math.min(0.3, this.speed + 0.05);
                        break;
                    case 'SPD_DN':
                        this.speed = Math.max(0.1, this.speed - 0.05);
                        break;
                    
                    // Score items
                    case 'SCORE_S': game.addScore(100); break;
                    case 'SCORE_M': game.addScore(500); break;
                    case 'SCORE_L': game.addScore(1000); break;
                    case 'SCORE_XL': game.addScore(5000); break;
                    case 'G_BOX': game.addScore(10000); break;
                    case 'M_BOX': game.addScore(20000); break;
                    case 'STAR': game.addScore(30000); break;
                    case 'MEDAL': game.addScore(50000); break;
                    
                    case 'MYSTERY':
                         // Recursive random
                         const randType = ITEM_TYPES[Math.floor(Math.random() * (ITEM_TYPES.length - 1))];
                         this.collectItem({type: randType});
                         return; // Don't double sound
                }
                game.updateUI();
                AudioSys.playPowerUp();
                game.addScore(100);
            }

            useBomb() {
                if (this.bombs > 0) {
                    this.bombs--;
                    AudioSys.playBomb();
                    game.shake(30);
                    
                    // Clear bullets
                    game.bullets = game.bullets.filter(b => b.isPlayer);
                    
                    // Damage enemies
                    game.enemies.forEach(e => {
                        e.hit(500); // Massive damage
                    });
                    
                    // Visual flash
                    let flash = document.createElement('div');
                    flash.style.position = 'absolute';
                    flash.style.top = '0';
                    flash.style.left = '0';
                    flash.style.width = '100%';
                    flash.style.height = '100%';
                    flash.style.background = 'white';
                    flash.style.opacity = '0.8';
                    flash.style.pointerEvents = 'none';
                    document.body.appendChild(flash);
                    setTimeout(() => flash.remove(), 100);

                    game.updateUI();
                }
            }
        }

        class Bullet extends Entity {
            constructor(x, y, vx, vy, isPlayer, damage, specialType = null) {
                super(x, y, 5);
                this.vx = vx;
                this.vy = vy;
                this.isPlayer = isPlayer;
                this.damage = damage;
                this.specialType = specialType; // 'HOMING', 'LASER'
                
                if (specialType === 'LASER') {
                    this.radius = 4; // Thicker laser
                    this.color = '#aaf';
                } else if (specialType === 'HOMING') {
                    this.radius = 8; // Bigger missiles
                    this.color = '#f0f';
                } else if (specialType === 'PLASMA') {
                    this.radius = 15; // Huge
                    this.color = '#0ff';
                } else {
                    this.color = isPlayer ? COLORS.bulletPlayer : COLORS.bulletEnemy;
                    if (isPlayer) this.radius = 8; // Bigger main bullets (was 5)
                }
            }

            update() {
                if (this.specialType === 'PLASMA') {
                     // Spin effect or pulse?
                     this.radius = 15 + Math.sin(game.frameCount * 0.5) * 3;
                }
                
                if (this.specialType === 'HOMING' && this.isPlayer) {
                    // Find nearest enemy
                    let nearest = null;
                    let minDist = 9999;
                    game.enemies.forEach(e => {
                        const d = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if (d < minDist) {
                            minDist = d;
                            nearest = e;
                        }
                    });

                    if (nearest) {
                        const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        this.vx += Math.cos(angle) * 0.5;
                        this.vy += Math.sin(angle) * 0.5;
                        // Clamp speed
                        const speed = Math.sqrt(this.vx**2 + this.vy**2);
                        if (speed > 10) {
                            this.vx = (this.vx / speed) * 10;
                            this.vy = (this.vy / speed) * 10;
                        }
                    }
                }

                this.x += this.vx;
                this.y += this.vy;

                // Bounds
                if (this.x < -50 || this.x > game.width + 50 || this.y < -50 || this.y > game.height + 50) {
                    this.markedForDeletion = true;
                }
            }

            draw() {
                CTX.save();
                CTX.translate(this.x, this.y);
                CTX.fillStyle = this.color;
                
                if (this.specialType === 'LASER') {
                    CTX.shadowBlur = 10;
                    CTX.shadowColor = '#00f';
                    CTX.fillRect(-3, -20, 6, 40); // Longer and thicker beam
                } else {
                    CTX.shadowBlur = 5;
                    CTX.shadowColor = this.color;
                    CTX.beginPath();
                    CTX.arc(0, 0, this.radius, 0, Math.PI*2);
                    CTX.fill();
                }
                CTX.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y, type) {
                super(x, y, 15);
                this.type = type; // 0: Drone, 1: Shooter, 2: Dasher
                this.hp = 20 * (game.difficulty * 0.5);
                this.scoreValue = 100;
                this.vy = 2 + Math.random() * 2;
                this.vx = (Math.random() - 0.5) * 1;
                
                if (type === 1) { // Shooter
                    this.hp *= 2;
                    this.scoreValue = 300;
                    this.radius = 20;
                    this.color = '#f80';
                } else if (type === 2) { // Dasher
                    this.hp *= 1.5;
                    this.vy = 5;
                    this.scoreValue = 200;
                    this.radius = 12;
                    this.color = '#f0f';
                } else {
                    this.color = '#f00';
                }
                
                this.lastShot = 0;
            }

            update() {
                this.y += this.vy;
                this.x += this.vx;
                
                // Movement logic
                if (this.type === 1) {
                    if (this.y > 100 && this.y < 300) this.vy *= 0.95; // Slow down to shoot
                    else this.vy += 0.05;
                    
                    // Shoot at player
                    if (game.frameCount - this.lastShot > 120 && this.y > 0 && this.y < game.height - 100) {
                        this.shoot();
                        this.lastShot = game.frameCount;
                    }
                }

                if (this.y > game.height + 50) this.markedForDeletion = true;
            }

            shoot() {
                if (!game.player) return;
                const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                const speed = 5;
                game.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, false, 10));
            }

            hit(dmg) {
                this.hp -= dmg;
                if (this.hp <= 0) {
                    this.die();
                } else {
                    // Flash effect
                    game.createParticles(this.x, this.y, 1, '#fff', 2);
                }
            }

            die() {
                this.markedForDeletion = true;
                game.createExplosion(this.x, this.y);
                game.addScore(this.scoreValue);
                
                // Drop Item Logic (15% chance)
                if (Math.random() < 0.15) {
                    // Weighted random
                    const r = Math.random();
                    let type = 'SCORE_S';
                    if (r < 0.3) type = 'SCORE_S';
                    else if (r < 0.5) type = 'PWR_S';
                    else if (r < 0.6) type = 'LIFE_S';
                    else if (r < 0.65) type = 'BOMB';
                    else if (r < 0.8) {
                        // Weapons
                        const weps = ['W_HOMING', 'W_LASER', 'W_SPREAD', 'W_PLASMA', 'W_VULCAN'];
                        type = weps[Math.floor(Math.random() * weps.length)];
                    } else {
                        // Rare stuff
                        const rares = ['PWR_MAX', 'LIFE_MAX', 'SHIELD', 'TIME_STOP', 'CLEAR_W', 'MYSTERY', 'MEDAL'];
                        type = rares[Math.floor(Math.random() * rares.length)];
                    }
                    
                    game.items.push(new Item(this.x, this.y, type));
                }
            }

            draw() {
                CTX.save();
                CTX.translate(this.x, this.y);
                CTX.fillStyle = this.color;
                CTX.shadowBlur = 10;
                CTX.shadowColor = this.color;
                
                if (this.type === 0) {
                    // Triangle pointing down
                    CTX.beginPath();
                    CTX.moveTo(-10, -10);
                    CTX.lineTo(10, -10);
                    CTX.lineTo(0, 15);
                    CTX.fill();
                } else if (this.type === 1) {
                    // Diamond
                    CTX.beginPath();
                    CTX.moveTo(0, -20);
                    CTX.lineTo(15, 0);
                    CTX.lineTo(0, 20);
                    CTX.lineTo(-15, 0);
                    CTX.fill();
                } else {
                    // Circle
                    CTX.beginPath();
                    CTX.arc(0, 0, this.radius, 0, Math.PI*2);
                    CTX.fill();
                }
                
                CTX.restore();
            }
        }

        class Boss extends Entity {
            constructor(x, y, level) {
                super(x, y, 60);
                this.isBoss = true;
                this.maxHp = 2000 * level;
                this.hp = this.maxHp;
                this.phase = 0;
                this.targetY = 150;
                this.angle = 0;
                this.lastShot = 0;
                this.state = 'ALIVE'; // ALIVE, DYING
                this.deathTimer = 0;
            }

            update() {
                if (this.state === 'DYING') {
                    this.deathTimer++;
                    // Shake screen violently
                    game.shake(5 + this.deathTimer * 0.2);
                    
                    // Random explosions
                    if (this.deathTimer % 8 === 0) {
                        const exX = this.x + (Math.random() - 0.5) * 100;
                        const exY = this.y + (Math.random() - 0.5) * 100;
                        game.createExplosion(exX, exY, 2);
                    }

                    // Final death
                    if (this.deathTimer > 180) { // 3 seconds
                        this.die();
                    }
                    return;
                }

                // Entrance
                if (this.y < this.targetY) {
                    this.y += 2;
                } else {
                    // Hover pattern
                    this.x += Math.sin(game.frameCount * 0.02) * 2;
                }

                // Attack Logic
                if (game.frameCount - this.lastShot > 60) {
                    this.attack();
                    this.lastShot = game.frameCount;
                }

                // Update UI HP
                const hpPercent = (this.hp / this.maxHp) * 100;
                game.uiBossHp.style.width = `${Math.max(0, hpPercent)}%`;
            }

            attack() {
                if (this.phase === 0) {
                    // Spread shot
                    for(let i=-2; i<=2; i++) {
                        game.bullets.push(new Bullet(this.x, this.y + 50, i*2, 6, false, 15));
                    }
                } else {
                    // Circular burst
                    for(let i=0; i<12; i++) {
                        const a = (Math.PI*2 / 12) * i + this.angle;
                        game.bullets.push(new Bullet(this.x, this.y, Math.cos(a)*5, Math.sin(a)*5, false, 15));
                    }
                    this.angle += 0.1;
                }
                
                // Switch phase based on HP
                if (this.hp < this.maxHp * 0.5) this.phase = 1;
            }

            hit(dmg) {
                if (this.state === 'DYING') return;
                this.hp -= dmg;
                if (this.hp <= 0) {
                    this.startDeathSequence();
                } else {
                     game.createParticles(this.x + (Math.random()-0.5)*50, this.y + (Math.random()-0.5)*50, 1, '#fff', 3);
                }
            }

            startDeathSequence() {
                this.state = 'DYING';
                this.deathTimer = 0;
                game.uiBossHpContainer.style.display = 'none';
                // Clear bullets for cinematic effect
                game.bullets = []; 
                AudioSys.playBossExplosion();
            }

            die() {
                this.markedForDeletion = true;
                // Massive final explosion
                game.createParticles(this.x, this.y, 200, '#ff0', 10);
                game.createParticles(this.x, this.y, 100, '#fff', 15);
                game.shake(50);
                AudioSys.playBomb(); // Big boom sound
                
                // Flash screen
                let flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.background = 'white';
                flash.style.zIndex = '100';
                document.body.appendChild(flash);
                setTimeout(() => {
                    flash.style.transition = 'opacity 2s';
                    flash.style.opacity = '0';
                    setTimeout(() => flash.remove(), 2000);
                }, 50);

                game.addScore(50000);
                
                // Loot Shower (24 items random)
                for(let i=0; i<10; i++) {
                    const itemType = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
                    const item = new Item(this.x, this.y, itemType);
                    item.vx = (Math.random() - 0.5) * 10;
                    item.vy = (Math.random() - 0.5) * 10; // Explode outwards
                    game.items.push(item);
                }
            }

            draw() {
                CTX.save();
                CTX.translate(this.x, this.y);
                if (this.state === 'DYING') {
                    CTX.globalAlpha = 0.5 + Math.sin(this.deathTimer * 0.5) * 0.5;
                    CTX.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);
                }
                
                CTX.fillStyle = '#a00';
                CTX.shadowBlur = 20;
                CTX.shadowColor = '#f00';
                
                // Big body
                CTX.beginPath();
                CTX.moveTo(0, 60);
                CTX.lineTo(50, -20);
                CTX.lineTo(20, -50);
                CTX.lineTo(-20, -50);
                CTX.lineTo(-50, -20);
                CTX.closePath();
                CTX.fill();

                // Core
                CTX.fillStyle = `hsl(${game.frameCount % 360}, 100%, 50%)`;
                CTX.beginPath();
                CTX.arc(0, 0, 20, 0, Math.PI*2);
                CTX.fill();
                
                CTX.restore();
            }
        }

        // --- ITEM SYSTEM (24 Types) ---
        const ITEM_TYPES = [
            'PWR_S', 'PWR_MAX', 'BOMB', 'LIFE_S', 'LIFE_MAX',
            'W_HOMING', 'W_LASER', 'W_SPREAD', 'W_PLASMA', 'W_VULCAN',
            'SHIELD', 'TIME_STOP', 'CLEAR_W', 'SPD_UP', 'SPD_DN',
            'SCORE_S', 'SCORE_M', 'SCORE_L', 'SCORE_XL',
            'G_BOX', 'M_BOX', 'STAR', 'MEDAL', 'MYSTERY'
        ];

        class Item extends Entity {
            constructor(x, y, type) {
                super(x, y, 15);
                this.type = type;
                this.vy = 2;
                this.vx = 0; // Support sideways movement
                this.color = '#fff';
                this.text = '?';
                this.blinkTimer = 0;
                
                // Visual Setup
                if (type.startsWith('PWR')) { this.color = '#f00'; this.text = 'P'; }
                else if (type === 'BOMB') { this.color = '#ff0'; this.text = 'B'; }
                else if (type.startsWith('LIFE')) { this.color = '#0f0'; this.text = 'H'; }
                else if (type.startsWith('W_')) { this.color = '#f0f'; this.text = type.split('_')[1][0]; } // H, L, S, P, V
                else if (type === 'SHIELD') { this.color = '#0ff'; this.text = 'S'; }
                else if (type === 'TIME_STOP') { this.color = '#aaa'; this.text = 'T'; }
                else if (type === 'CLEAR_W') { this.color = '#fff'; this.text = 'C'; }
                else if (type.startsWith('SPD')) { this.color = '#00f'; this.text = '>'; }
                else if (type.startsWith('SCORE')) { this.color = '#ffd700'; this.text = '$'; }
                else { this.color = '#fff'; this.text = '?'; }
            }

            update() {
                this.y += this.vy;
                this.x += this.vx;
                this.vx *= 0.95; // Friction for loot shower

                // Bounce off walls
                if (this.x < 20 || this.x > game.width - 20) {
                    this.vx *= -1;
                    this.x = Math.max(20, Math.min(game.width-20, this.x));
                }
                
                if (this.y > game.height + 20) this.markedForDeletion = true;
                
                this.blinkTimer++;
            }

            draw() {
                CTX.save();
                CTX.translate(this.x, this.y);
                
                // Blinking Effect
                const scale = 1 + Math.sin(this.blinkTimer * 0.2) * 0.1;
                CTX.scale(scale, scale);

                CTX.fillStyle = this.color;
                CTX.shadowBlur = 10;
                CTX.shadowColor = this.color;
                
                // Hexagon shape for variety
                CTX.beginPath();
                for (let i = 0; i < 6; i++) {
                    CTX.lineTo(15 * Math.cos(i * Math.PI / 3), 15 * Math.sin(i * Math.PI / 3));
                }
                CTX.closePath();
                CTX.fill();
                
                // Inner text
                CTX.fillStyle = '#000';
                CTX.font = 'bold 16px Arial';
                CTX.textAlign = 'center';
                CTX.textBaseline = 'middle';
                CTX.fillText(this.text, 0, 0);
                
                // Sub-text for detail (e.g. MAX)
                if (this.type.includes('MAX')) {
                    CTX.fillStyle = '#fff';
                    CTX.font = '8px Arial';
                    CTX.fillText('MAX', 0, 10);
                }

                CTX.restore();
            }
        }

        class Particle {
            constructor(x, y, color, speed) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = Math.random() * speed + 1;
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
                this.markedForDeletion = false;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                if (this.life <= 0) this.markedForDeletion = true;
            }

            draw() {
                CTX.save();
                CTX.globalAlpha = this.life;
                CTX.fillStyle = this.color;
                CTX.fillRect(this.x, this.y, 3, 3);
                CTX.restore();
            }
        }

        // --- START GAME ---
        const game = new Game();

    </script>
</body>
</html>
