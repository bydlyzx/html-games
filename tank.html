<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç»å…¸å¦å…‹å¤§æˆ˜å¤åˆ»ç‰ˆ</title>
    <style>
        :root {
            --cabinet-bg: #2b2b2b;
            --screen-bg: #050505;
            --neon-glow: rgba(200, 255, 200, 0.1);
        }
        body {
            background-color: #111;
            background-image: radial-gradient(circle at center, #222 0%, #000 100%);
            color: #fff;
            font-family: 'Segoe UI', 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }
        
        /* è¡—æœºå¤–å£³å®¹å™¨ */
        #arcade-cabinet {
            position: relative;
            background: linear-gradient(145deg, #333, #1a1a1a);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 
                0 0 0 10px #151515, /* å¤–æ¡† */
                0 20px 50px rgba(0,0,0,0.8), /* æŠ•å½± */
                inset 0 0 20px rgba(0,0,0,0.5); /* å†…é˜´å½± */
            border: 2px solid #444;
        }

        /* å±å¹•è¾¹æ¡† */
        #screen-bezel {
            position: relative;
            background: #000;
            padding: 20px;
            border-radius: 10px; /* å±å¹•åœ†è§’ */
            box-shadow: inset 0 0 20px rgba(0,0,0,1);
            border: 4px solid #333;
        }

        #game-container {
            position: relative;
            width: 780px;  /* æ”¾å¤§æ˜¾ç¤ºå°ºå¯¸ */
            height: 780px;
            overflow: hidden;
            border-radius: 4px;
            background-color: var(--screen-bg);
            /* CRT æ‰«æçº¿æ•ˆæœ */
            background-image: linear-gradient(
                rgba(18, 16, 16, 0) 50%, 
                rgba(0, 0, 0, 0.25) 50%
            ), linear-gradient(
                90deg, 
                rgba(255, 0, 0, 0.06), 
                rgba(0, 255, 0, 0.02), 
                rgba(0, 0, 255, 0.06)
            );
            background-size: 100% 4px, 6px 100%;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
        }
        
        /* å±å¹•å‘å…‰ */
        #game-container::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: radial-gradient(circle, rgba(255,255,255,0) 60%, rgba(0,0,0,0.4) 100%);
            pointer-events: none;
            z-index: 5;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* image-rendering: pixelated; ç§»é™¤åƒç´ åŒ–ï¼Œä½¿ç”¨å¹³æ»‘ç¼©æ”¾é…åˆé«˜æ¸…çº¹ç† */
            filter: contrast(1.1) brightness(1.1) saturate(1.2);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 6;
        }
        .hud-text {
            font-size: 24px;
            font-family: 'Impact', sans-serif;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 2px 2px 0 #000, 0 0 10px rgba(0, 255, 0, 0.5);
            letter-spacing: 2px;
        }
        
        /* è£…é¥°æ€§è´´çº¸/æ–‡å­— */
        .cabinet-label {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-family: 'Arial Black', sans-serif;
            color: #555;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 1px 0 rgba(255,255,255,0.1);
        }

        #start-screen, #game-over-screen, #victory-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            backdrop-filter: blur(2px);
        }
        
        h1 { 
            margin: 0 0 30px 0; 
            font-size: 60px; 
            text-transform: uppercase; 
            color: #e44; 
            font-family: 'Impact', sans-serif;
            letter-spacing: 5px;
            text-shadow: 
                4px 4px 0 #000,
                0 0 20px rgba(255, 0, 0, 0.5);
            transform: skew(-5deg);
        }
        
        p { margin: 15px 0; font-size: 22px; color: #ccc; font-weight: bold; text-shadow: 1px 1px 0 #000; }
        .blink { animation: blink 0.8s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; text-shadow: 0 0 10px yellow; } 50% { opacity: 0.3; } }
        .hidden { display: none !important; }
        
        #victory-content { text-align: center; }
        #cigar-guy-canvas { 
            margin: 30px auto; 
            border: 4px solid #fff; 
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
            background: #000;
        }
    </style>
</head>
<body>

<div id="arcade-cabinet">
    <div id="screen-bezel">
        <div id="game-container">
            <canvas id="gameCanvas" width="780" height="780"></canvas>
            
            <div id="ui-layer">
                <div class="hud-text">P1 ğŸ›¡ï¸ <span id="p1-lives">3</span></div>
                <div class="hud-text" style="text-align: right;">ENEMY ğŸ‘¾ <span id="enemy-count">0</span></div>
            </div>

            <div id="start-screen">
                <h1>TANK BATTLE</h1>
                <p>PRESS <span style="color:#fd0">[SPACE]</span> TO START</p>
                <p style="font-size: 16px; color: #888;">WASD / ARROWS to Move &bull; SPACE to Fire</p>
            </div>

            <div id="game-over-screen" class="hidden">
                <h1 style="color: #888; text-shadow: 0 0 10px #fff;">GAME OVER</h1>
                <p class="blink">PRESS SPACE TO RESTART</p>
            </div>

            <div id="victory-screen" class="hidden">
                <div id="victory-content">
                    <h1 style="color: #fd0; text-shadow: 4px 4px 0 #b80;">VICTORY!</h1>
                    <canvas id="cigar-guy-canvas" width="200" height="150"></canvas>
                    <p class="blink">PRESS SPACE TO PLAY AGAIN</p>
                </div>
            </div>
        </div>
    </div>
    <div class="cabinet-label">INSERT COIN</div>
</div>

<script>
/**
 * ç»å…¸å¦å…‹å¤§æˆ˜å¤åˆ»ç‰ˆ - å•æ–‡ä»¶å®ç°
 * åŒ…å«ï¼šæ¸¸æˆå¾ªç¯ã€æ¸²æŸ“ã€ç‰©ç†ã€AIã€éŸ³é¢‘ã€å…³å¡ç”Ÿæˆ
 */

// --- å¸¸é‡å®šä¹‰ ---
const TILE_SIZE = 30; // å‡çº§ä¸º 30px (åŸ 20px)
const MAP_SIZE = 26;  // åœ°å›¾ 26x26 æ ¼
const CANVAS_SIZE = TILE_SIZE * MAP_SIZE; // 780px
const FPS = 60;

const DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
const TILE = { EMPTY: 0, BRICK: 1, STEEL: 2, WATER: 3, GRASS: 4, BASE: 9 };

// --- å…¨å±€çŠ¶æ€ ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// å¼€å¯å¹³æ»‘å¤„ç†ä»¥è·å¾—æ›´å¥½çš„æ¸å˜æ•ˆæœ
ctx.imageSmoothingEnabled = true;

const victoryCanvas = document.getElementById('cigar-guy-canvas');
const victoryCtx = victoryCanvas.getContext('2d');

let gameRunning = false;
let gamePaused = false;
let frameCount = 0;
let lastTime = 0;

// --- éŸ³é¢‘ç³»ç»Ÿ (Web Audio API) ---
const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol = 0.2) {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        
        // ç®€å•çš„ä½é€šæ»¤æ³¢å™¨è®©çˆ†ç‚¸å¬èµ·æ¥æ›´æ²‰é—·
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    shoot: function() { this.playTone(400, 'square', 0.1, 0.1); },
    explode: function() { this.playNoise(0.4, 0.4); },
    hitBrick: function() { this.playTone(150, 'sawtooth', 0.05, 0.1); },
    hitSteel: function() { this.playTone(800, 'square', 0.05, 0.05); },
    move: function() { 
        if(frameCount % 10 === 0) this.playTone(60, 'triangle', 0.05, 0.05); 
    },
    startMusic: function() {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.type = 'triangle';
        
        [523, 0, 523, 0, 523, 0, 392, 440, 523, 0, 392, 523].forEach((f, i) => {
            if (f > 0) {
                osc.frequency.setValueAtTime(f, now + i * 0.12);
                gain.gain.setValueAtTime(0.1, now + i * 0.12);
                gain.gain.setValueAtTime(0, now + i * 0.12 + 0.1);
            }
        });
        osc.start();
        osc.stop(now + 2.5);
    },
    victoryMusic: function() {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        const notes = [
            {f: 523, d: 0.2}, {f: 659, d: 0.2}, {f: 784, d: 0.2}, {f: 1046, d: 0.4},
            {f: 784, d: 0.2}, {f: 1046, d: 0.8}
        ];
        
        let t = now;
        notes.forEach(n => {
            osc.frequency.setValueAtTime(n.f, t);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.setValueAtTime(0, t + n.d - 0.05);
            t += n.d;
        });
        
        osc.start();
        osc.stop(t);
    }
};

// --- è¾“å…¥å¤„ç† ---
const Input = {
    keys: {},
    init: function() {
        window.addEventListener('keydown', e => {
            this.keys[e.code] = true;
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
            if(e.code === 'Space') {
                if(!gameRunning) {
                    if(!document.getElementById('victory-screen').classList.contains('hidden')) {
                         Game.reset();
                    } else if (!document.getElementById('game-over-screen').classList.contains('hidden')) {
                         Game.reset();
                    } else if (!document.getElementById('start-screen').classList.contains('hidden')) {
                         Game.start();
                    }
                }
            }
        });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
    },
    isDown: function(code) { return this.keys[code]; }
};

// --- èµ„æºç”Ÿæˆ (é«˜æ¸…æ‹Ÿç‰©é£æ ¼) ---
const Assets = {
    textures: {},
    generate: function() {
        this.textures.player = this.createTankTexture('#fcb045', '#fd1d1d'); // ç©å®¶ï¼šé‡‘è‰²æ¸å˜
        this.textures.enemy1 = this.createTankTexture('#e0e0e0',('#999')); // æ™®é€šï¼šé“¶è‰²
        this.textures.enemy2 = this.createTankTexture('#83a4d4', '#b6fbff'); // å¿«é€Ÿï¼šé’è‰²
        this.textures.enemy3 = this.createTankTexture('#11998e', '#38ef7d'); // é‡è£…ï¼šç»¿è‰²
        
        this.textures.brick = this.createBrickTexture();
        this.textures.steel = this.createSteelTexture();
        this.textures.grass = this.createGrassTexture();
    },
    
    // åˆ›å»ºå¸¦å…‰å½±çš„å¦å…‹
    createTankTexture: function(color1, color2) {
        const c = document.createElement('canvas');
        c.width = TILE_SIZE; c.height = TILE_SIZE;
        const x = c.getContext('2d');
        
        // å±¥å¸¦
        x.fillStyle = '#111';
        x.fillRect(2, 2, 6, 26); 
        x.fillRect(22, 2, 6, 26);
        
        // å±¥å¸¦ç»†èŠ‚
        x.fillStyle = '#333';
        for(let i=0; i<6; i++) {
            x.fillRect(2, 4 + i*4, 6, 2);
            x.fillRect(22, 4 + i*4, 6, 2);
        }

        // è½¦èº« (çº¿æ€§æ¸å˜)
        const bodyGrad = x.createLinearGradient(8, 0, 22, 0);
        bodyGrad.addColorStop(0, color1);
        bodyGrad.addColorStop(1, color2 || color1);
        
        // é˜´å½±
        x.shadowColor = 'rgba(0,0,0,0.5)';
        x.shadowBlur = 4;
        
        x.fillStyle = bodyGrad;
        x.fillRect(8, 5, 14, 18); // ä¸»ä½“
        
        x.shadowBlur = 0; // é‡ç½®é˜´å½±

        // é©¾é©¶èˆ±/ç‚®å¡” (å¾„å‘æ¸å˜)
        const turretGrad = x.createRadialGradient(15, 14, 0, 15, 14, 8);
        turretGrad.addColorStop(0, '#eee');
        turretGrad.addColorStop(1, '#999');
        
        x.fillStyle = turretGrad;
        x.beginPath();
        x.arc(15, 14, 5, 0, Math.PI*2);
        x.fill();
        
        // ç‚®ç®¡
        x.fillStyle = '#444';
        x.fillRect(13, 0, 4, 10);
        
        // ç‚®å£
        x.fillStyle = '#000';
        x.fillRect(14, 0, 2, 2);
        
        return c;
    },
    
    // æ‹Ÿç‰©ç –å— (å¸¦å€’è§’å’Œçº¹ç†)
    createBrickTexture: function() {
        const c = document.createElement('canvas');
        c.width = TILE_SIZE; c.height = TILE_SIZE;
        const x = c.getContext('2d');
        
        // èƒŒæ™¯ç°æ³¥
        x.fillStyle = '#944';
        x.fillRect(0,0,TILE_SIZE,TILE_SIZE);
        
        const drawSingleBrick = (bx, by, bw, bh) => {
            // ç –é¢
            const g = x.createLinearGradient(bx, by, bx, by+bh);
            g.addColorStop(0, '#d66');
            g.addColorStop(1, '#a33');
            x.fillStyle = g;
            x.fillRect(bx, by, bw, bh);
            
            // é«˜å…‰å’Œé˜´å½± (Bevel)
            x.fillStyle = 'rgba(255,255,255,0.2)';
            x.fillRect(bx, by, bw, 2); // Top
            x.fillRect(bx, by, 2, bh); // Left
            
            x.fillStyle = 'rgba(0,0,0,0.3)';
            x.fillRect(bx, by+bh-2, bw, 2); // Bottom
            x.fillRect(bx+bw-2, by, 2, bh); // Right
        };
        
        // ç»˜åˆ¶äº¤é”™çš„ç –å—
        const h = TILE_SIZE/2;
        drawSingleBrick(0, 0, TILE_SIZE, h-1);
        drawSingleBrick(0, h, TILE_SIZE/2-1, h);
        drawSingleBrick(TILE_SIZE/2, h, TILE_SIZE/2, h);
        
        return c;
    },
    
    // æ‹Ÿç‰©é’¢å— (é‡‘å±å…‰æ³½ + é“†é’‰)
    createSteelTexture: function() {
        const c = document.createElement('canvas');
        c.width = TILE_SIZE; c.height = TILE_SIZE;
        const x = c.getContext('2d');
        
        // é‡‘å±è¡¨é¢
        const g = x.createLinearGradient(0,0,TILE_SIZE,TILE_SIZE);
        g.addColorStop(0, '#bbb');
        g.addColorStop(0.5, '#fff');
        g.addColorStop(1, '#999');
        x.fillStyle = g;
        x.fillRect(0,0,TILE_SIZE,TILE_SIZE);
        
        // å†…æ¡†
        x.lineWidth = 2;
        x.strokeStyle = '#666';
        x.strokeRect(2,2,TILE_SIZE-4, TILE_SIZE-4);
        
        // åå­—äº¤å‰
        x.beginPath();
        x.moveTo(TILE_SIZE, 0);
        x.lineTo(0, TILE_SIZE);
        x.strokeStyle = 'rgba(0,0,0,0.1)';
        x.stroke();
        
        // é“†é’‰
        x.fillStyle = '#555';
        const rivet = (rx, ry) => {
            x.beginPath();
            x.arc(rx, ry, 2, 0, Math.PI*2);
            x.fill();
        };
        rivet(5,5); rivet(TILE_SIZE-5, 5);
        rivet(5, TILE_SIZE-5); rivet(TILE_SIZE-5, TILE_SIZE-5);
        
        return c;
    },
    
    createGrassTexture: function() {
        const c = document.createElement('canvas');
        c.width = TILE_SIZE; c.height = TILE_SIZE;
        const x = c.getContext('2d');
        
        x.fillStyle = '#050';
        x.fillRect(0,0,TILE_SIZE,TILE_SIZE);
        
        x.fillStyle = '#1a1';
        for(let i=0;i<16;i++) {
            const lx = Math.random()*TILE_SIZE;
            const ly = Math.random()*TILE_SIZE;
            x.fillRect(lx, ly, 2, 4);
        }
        return c;
    }
};

// --- æ¸¸æˆå¯¹è±¡ç±» ---

class GameObject {
    constructor(x, y, w, h) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.markedForDeletion = false;
    }
    draw(ctx) {}
    update() {}
    get rect() { return { x: this.x, y: this.y, w: this.w, h: this.h }; }
}

class Bullet extends GameObject {
    constructor(x, y, dir, owner) {
        super(x, y, 8, 8); // å­å¼¹å˜å¤§ä¸€ç‚¹
        this.dir = dir;
        this.owner = owner; 
        this.speed = 6; // é€Ÿåº¦æå‡é€‚é…å¤§åœ°å›¾
        
        // ä¿®æ­£åˆå§‹ä½ç½®
        const centerOffset = TILE_SIZE / 2 - 4;
        if (dir === DIR.UP) { this.x += centerOffset; this.y -= 8; }
        else if (dir === DIR.DOWN) { this.x += centerOffset; this.y += TILE_SIZE; }
        else if (dir === DIR.LEFT) { this.x -= 8; this.y += centerOffset; }
        else if (dir === DIR.RIGHT) { this.x += TILE_SIZE; this.y += centerOffset; }
    }
    update() {
        if (this.dir === DIR.UP) this.y -= this.speed;
        else if (this.dir === DIR.DOWN) this.y += this.speed;
        else if (this.dir === DIR.LEFT) this.x -= this.speed;
        else if (this.dir === DIR.RIGHT) this.x += this.speed;

        if (this.x < 0 || this.x > CANVAS_SIZE || this.y < 0 || this.y > CANVAS_SIZE) {
            this.markedForDeletion = true;
            return;
        }

        if (Map.checkBulletCollision(this)) {
            this.markedForDeletion = true;
            AudioSys.hitBrick();
            Game.spawnExplosion(this.x, this.y, 0); 
            return;
        }

        Game.tanks.forEach(tank => {
            if (tank !== this.owner && !tank.markedForDeletion) {
                const isEnemyBullet = this.owner instanceof EnemyTank;
                const isPlayer = tank instanceof PlayerTank;
                
                if (isEnemyBullet && !isPlayer) return; 
                if (!isEnemyBullet && isPlayer) return; 

                if (Physics.checkCollision(this.rect, tank.rect)) {
                    this.markedForDeletion = true;
                    tank.takeDamage();
                    Game.spawnExplosion(tank.x, tank.y, 1); 
                }
            }
        });
        
        Game.bullets.forEach(b => {
             if (b !== this && !b.markedForDeletion && b.owner !== this.owner) {
                 if (Physics.checkCollision(this.rect, b.rect)) {
                     this.markedForDeletion = true;
                     b.markedForDeletion = true;
                 }
             }
        });
    }
    draw(ctx) {
        ctx.save();
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.owner instanceof PlayerTank ? '#ff0' : '#f00';
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x + 4, this.y + 4, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

class Tank extends GameObject {
    constructor(x, y, type) {
        super(x, y, TILE_SIZE, TILE_SIZE);
        this.dir = DIR.UP;
        this.speed = 2.5; // é€Ÿåº¦é€‚é…
        this.moving = false;
        this.cooldown = 0;
        this.texture = Assets.textures.enemy1;
        this.hp = 1;
        this.isPlayer = false;
    }
    update() {
        if (this.cooldown > 0) this.cooldown--;
        
        if (this.moving) {
            let nextX = this.x;
            let nextY = this.y;
            
            if (this.dir === DIR.UP) nextY -= this.speed;
            else if (this.dir === DIR.DOWN) nextY += this.speed;
            else if (this.dir === DIR.LEFT) nextX -= this.speed;
            else if (this.dir === DIR.RIGHT) nextX += this.speed;

            const rect = { x: nextX, y: nextY, w: this.w, h: this.h };
            if (!Map.checkCollision(rect) && !Game.checkTankCollision(this, rect)) {
                this.x = nextX;
                this.y = nextY;
                
                // å¸é™„ç½‘æ ¼
                if (this.dir === DIR.UP || this.dir === DIR.DOWN) {
                    const gridX = Math.round(this.x / TILE_SIZE) * TILE_SIZE;
                    if (Math.abs(this.x - gridX) < 6) this.x = gridX;
                } else {
                    const gridY = Math.round(this.y / TILE_SIZE) * TILE_SIZE;
                    if (Math.abs(this.y - gridY) < 6) this.y = gridY;
                }
            } else {
                this.onCollision();
            }
        }
    }
    shoot() {
        if (this.cooldown <= 0) {
            Game.bullets.push(new Bullet(this.x, this.y, this.dir, this));
            this.cooldown = 30; 
            AudioSys.shoot();
        }
    }
    takeDamage() {
        this.hp--;
        if (this.hp <= 0) {
            this.markedForDeletion = true;
            AudioSys.explode();
            this.onDestroy();
        }
    }
    onCollision() {}
    onDestroy() {}
    draw(ctx) {
        ctx.save();
        // é˜´å½±
        ctx.shadowColor = 'rgba(0,0,0,0.6)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 4;
        
        ctx.translate(Math.round(this.x + this.w/2), Math.round(this.y + this.h/2));
        ctx.rotate(this.dir * 90 * Math.PI / 180);
        ctx.drawImage(this.texture, -this.w/2, -this.h/2);
        ctx.restore();
    }
}

class PlayerTank extends Tank {
    constructor(x, y) {
        super(x, y);
        this.texture = Assets.textures.player;
        this.hp = 1;
        this.isPlayer = true;
        this.speed = 3;
    }
    update() {
        this.moving = false;
        let newDir = -1;
        
        if (Input.isDown('ArrowUp') || Input.isDown('KeyW')) newDir = DIR.UP;
        else if (Input.isDown('ArrowDown') || Input.isDown('KeyS')) newDir = DIR.DOWN;
        else if (Input.isDown('ArrowLeft') || Input.isDown('KeyA')) newDir = DIR.LEFT;
        else if (Input.isDown('ArrowRight') || Input.isDown('KeyD')) newDir = DIR.RIGHT;

        if (newDir !== -1) {
            this.dir = newDir;
            this.moving = true;
            AudioSys.move();
        }

        if (Input.isDown('Space')) {
            this.shoot();
        }

        super.update();
    }
    onDestroy() {
        Game.gameOver();
    }
}

class EnemyTank extends Tank {
    constructor(x, y, type) {
        super(x, y);
        this.type = type; 
        this.changeDirTimer = 0;
        
        if (type === 1) {
            this.speed = 4;
            this.texture = Assets.textures.enemy2;
        } else if (type === 2) {
            this.speed = 1.5;
            this.hp = 3;
            this.texture = Assets.textures.enemy3;
        } else {
            this.speed = 2.5;
            this.texture = Assets.textures.enemy1;
        }
    }
    update() {
        if (this.changeDirTimer-- <= 0) {
            this.changeDirTimer = Math.random() * 60 + 30;
            this.chooseDirection();
        }
        this.moving = true;
        super.update();
        if (Math.random() < 0.02) this.shoot();
    }
    chooseDirection() {
        const r = Math.random();
        if (r < 0.5 && Game.player) {
            if (Math.abs(Game.player.x - this.x) > Math.abs(Game.player.y - this.y)) {
                this.dir = (Game.player.x > this.x) ? DIR.RIGHT : DIR.LEFT;
            } else {
                this.dir = (Game.player.y > this.y) ? DIR.DOWN : DIR.UP;
            }
        } else {
            this.dir = Math.floor(Math.random() * 4);
        }
    }
    onCollision() {
        if (Math.random() < 0.8) this.chooseDirection();
    }
    onDestroy() {
        Game.enemiesLeft--;
        Game.ui.update();
        if (Game.enemiesLeft <= 0 && Game.spawner.count <= 0) {
            Game.victory();
        }
    }
}

class Particle extends GameObject {
    constructor(x, y, type) {
        super(x, y, 0, 0);
        this.type = type; // 0: small, 1: big
        this.life = type === 0 ? 15 : 40;
        this.maxLife = this.life;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        if (this.life <= 0) this.markedForDeletion = true;
    }
    draw(ctx) {
        const progress = this.life / this.maxLife;
        const radius = (this.type === 0 ? 15 : 40) * progress;
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter'; // çˆ†ç‚¸å‘å…‰
        ctx.beginPath();
        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
        
        const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius);
        g.addColorStop(0, '#fff');
        g.addColorStop(0.5, '#fa0');
        g.addColorStop(1, 'rgba(255,0,0,0)');
        
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();
    }
}

// --- åœ°å›¾ä¸ç‰©ç† ---
const Map = {
    grid: [],
    init: function() {
        this.grid = [];
        for (let y = 0; y < MAP_SIZE; y++) {
            const row = [];
            for (let x = 0; x < MAP_SIZE; x++) {
                let tile = TILE.EMPTY;
                if (x === 0 || x === MAP_SIZE - 1 || y === 0 || y === MAP_SIZE - 1) {
                    tile = TILE.STEEL;
                } else if (Math.random() < 0.15) {
                    tile = TILE.BRICK;
                } else if (Math.random() < 0.02) {
                    tile = TILE.STEEL;
                }
                if ((x >= 11 && x <= 14) && (y >= 23)) {
                     tile = TILE.EMPTY; 
                }
                row.push(tile);
            }
            this.grid.push(row);
        }
        
        this.grid[23][11] = TILE.BRICK;
        this.grid[23][12] = TILE.BRICK;
        this.grid[23][13] = TILE.BRICK;
        this.grid[23][14] = TILE.BRICK;
        this.grid[24][11] = TILE.BRICK;
        this.grid[24][14] = TILE.BRICK;
        this.grid[25][11] = TILE.BRICK;
        this.grid[25][14] = TILE.BRICK;
        
        this.grid[25][12] = TILE.BASE; 
        this.grid[25][13] = TILE.BASE;
    },
    draw: function(ctx) {
        for (let y = 0; y < MAP_SIZE; y++) {
            for (let x = 0; x < MAP_SIZE; x++) {
                const t = this.grid[y][x];
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                
                if (t === TILE.BRICK) ctx.drawImage(Assets.textures.brick, px, py);
                else if (t === TILE.STEEL) ctx.drawImage(Assets.textures.steel, px, py);
                else if (t === TILE.GRASS) ctx.drawImage(Assets.textures.grass, px, py);
                else if (t === TILE.BASE) {
                    // åŸºåœ°ç»˜åˆ¶ä¼˜åŒ–
                    ctx.save();
                    ctx.shadowColor = '#f0f';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#f0f'; 
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    // é¹°æ ‡ç»†èŠ‚
                    ctx.fillStyle = '#fff';
                    ctx.font = '20px Arial';
                    ctx.fillText('ğŸ¦…', px + 2, py + 24);
                    ctx.restore();
                }
            }
        }
    },
    checkCollision: function(rect) {
        const minX = Math.floor(rect.x / TILE_SIZE);
        const maxX = Math.floor((rect.x + rect.w - 1) / TILE_SIZE);
        const minY = Math.floor(rect.y / TILE_SIZE);
        const maxY = Math.floor((rect.y + rect.h - 1) / TILE_SIZE);

        for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
                if (y >= 0 && y < MAP_SIZE && x >= 0 && x < MAP_SIZE) {
                    const t = this.grid[y][x];
                    if (t === TILE.BRICK || t === TILE.STEEL || t === TILE.WATER) return true;
                }
            }
        }
        return false;
    },
    checkBulletCollision: function(bullet) {
        const cx = bullet.x + bullet.w/2;
        const cy = bullet.y + bullet.h/2;
        const gx = Math.floor(cx / TILE_SIZE);
        const gy = Math.floor(cy / TILE_SIZE);

        if (gx >= 0 && gx < MAP_SIZE && gy >= 0 && gy < MAP_SIZE) {
            const t = this.grid[gy][gx];
            if (t === TILE.BRICK) {
                this.grid[gy][gx] = TILE.EMPTY; 
                return true;
            } else if (t === TILE.STEEL) {
                AudioSys.hitSteel();
                return true;
            }
        }
        return false;
    }
};

const Physics = {
    checkCollision: function(r1, r2) {
        return r1.x < r2.x + r2.w &&
               r1.x + r1.w > r2.x &&
               r1.y < r2.y + r2.h &&
               r1.y + r1.h > r2.y;
    }
};

// --- æ¸¸æˆä¸»æ§ ---
const Game = {
    player: null,
    tanks: [],
    bullets: [],
    particles: [],
    enemiesLeft: 0,
    spawner: {
        timer: 0,
        count: 0,
        locations: [{x:0, y:0}, {x:12, y:0}, {x:24, y:0}]
    },
    ui: {
        update: function() {
            document.getElementById('enemy-count').innerText = Game.enemiesLeft + Game.spawner.count;
            if (Game.player) document.getElementById('p1-lives').innerText = Game.player.hp;
        }
    },
    
    start: function() {
        AudioSys.init();
        Assets.generate();
        Input.init();
        
        this.resetLevel();
        gameRunning = true;
        gamePaused = false;
        AudioSys.startMusic();
        
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('victory-screen').classList.add('hidden');
        
        requestAnimationFrame(this.loop);
    },
    
    resetLevel: function() {
        Map.init();
        this.tanks = [];
        this.bullets = [];
        this.particles = [];
        
        // ç©å®¶å‡ºç”Ÿ
        this.player = new PlayerTank(9 * TILE_SIZE, 24 * TILE_SIZE);
        this.tanks.push(this.player);
        
        // æ•Œäººè®¾ç½®
        this.enemiesLeft = 10; // æ€»å…±éœ€æ¶ˆç­
        this.spawner.count = 10; // å¾…ç”Ÿæˆ
        this.spawner.timer = 0;
        
        this.ui.update();
    },
    
    reset: function() {
        this.start();
    },
    
    loop: function(timestamp) {
        if (!gameRunning) return;
        
        // é™åˆ¶å¸§ç‡
        // (ç®€å•èµ·è§ï¼Œè¿™é‡Œæ¯å¸§éƒ½è·‘ï¼Œå®é™…åº”è®¡ç®—delta)
        
        Game.update();
        Game.draw();
        
        frameCount++;
        requestAnimationFrame(Game.loop);
    },
    
    update: function() {
        // æ•Œäººç”Ÿæˆ
        if (this.spawner.count > 0 && this.tanks.length < 5) {
            if (this.spawner.timer-- <= 0) {
                const loc = this.spawner.locations[Math.floor(Math.random() * 3)];
                // æ£€æŸ¥å‡ºç”Ÿç‚¹æ˜¯å¦æœ‰å¦å…‹
                let clear = true;
                const spawnRect = {x: loc.x*TILE_SIZE, y: loc.y*TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE};
                for(let t of this.tanks) {
                    if (Physics.checkCollision(spawnRect, t.rect)) clear = false;
                }
                
                if (clear) {
                    const type = Math.floor(Math.random() * 3);
                    this.tanks.push(new EnemyTank(loc.x * TILE_SIZE, loc.y * TILE_SIZE, type));
                    this.spawner.count--;
                    this.spawner.timer = 180; // 3ç§’
                }
            }
        }
        
        // æ›´æ–°æ‰€æœ‰å¯¹è±¡
        this.tanks.forEach(t => t.update());
        this.bullets.forEach(b => b.update());
        this.particles.forEach(p => p.update());
        
        // æ¸…ç†
        this.tanks = this.tanks.filter(t => !t.markedForDeletion);
        this.bullets = this.bullets.filter(b => !b.markedForDeletion);
        this.particles = this.particles.filter(p => !p.markedForDeletion);
        
        // æ£€æŸ¥ç©å®¶æ˜¯å¦å­˜åœ¨
        if (this.player && this.player.markedForDeletion) {
            this.player = null;
            // Game Over é€»è¾‘åœ¨ player.onDestroy è°ƒç”¨
        }
    },
    
    draw: function() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        Map.draw(ctx);
        
        // å…ˆç”»å°¸ä½“/ç—•è¿¹ (å¯é€‰)
        
        this.tanks.forEach(t => t.draw(ctx));
        this.bullets.forEach(b => b.draw(ctx));
        this.particles.forEach(p => p.draw(ctx));
    },
    
    checkTankCollision: function(tank, rect) {
        for (let other of this.tanks) {
            if (other !== tank) {
                if (Physics.checkCollision(rect, other.rect)) return true;
            }
        }
        return false;
    },
    
    spawnExplosion: function(x, y, type) {
        this.particles.push(new Particle(x, y, type));
    },
    
    gameOver: function() {
        gameRunning = false;
        document.getElementById('game-over-screen').classList.remove('hidden');
    },
    
    victory: function() {
        gameRunning = false;
        document.getElementById('victory-screen').classList.remove('hidden');
        AudioSys.victoryMusic();
        VictoryScene.play();
    }
};

// --- èƒœåˆ©ç”»é¢ (Cigar Guy) ---
const VictoryScene = {
    play: function() {
        // ç»˜åˆ¶èƒœåˆ©åŠ¨ç”»è§’è‰²
        // ä¸€ä¸ªç®€å•çš„åƒç´ é£æ ¼å¤§å…µå¤´
        const vCtx = victoryCtx;
        vCtx.clearRect(0,0,200,150);
        
        // ç»˜åˆ¶å¤´éƒ¨
        vCtx.fillStyle = '#fca';
        vCtx.fillRect(60, 40, 80, 80); // è„¸
        
        // é’¢ç›”
        vCtx.fillStyle = '#484';
        vCtx.beginPath();
        vCtx.arc(100, 50, 45, Math.PI, 0);
        vCtx.fill();
        vCtx.fillRect(55, 50, 90, 10);
        
        // å¢¨é•œ
        vCtx.fillStyle = '#000';
        vCtx.fillRect(70, 60, 25, 15);
        vCtx.fillRect(105, 60, 25, 15);
        vCtx.fillStyle = '#444'; // åå…‰
        vCtx.fillRect(72, 62, 5, 5);
        vCtx.fillRect(107, 62, 5, 5);
        vCtx.fillRect(95, 65, 10, 2); // æ¶å­
        
        // å˜´å·´ & é›ªèŒ„
        vCtx.fillStyle = '#a55';
        vCtx.fillRect(90, 95, 20, 5); // å˜´
        
        vCtx.fillStyle = '#631';
        vCtx.fillRect(100, 95, 40, 6); // é›ªèŒ„èº«
        vCtx.fillStyle = '#f00';
        vCtx.fillRect(140, 95, 4, 6); // ç‡ƒçƒ§å¤´
        vCtx.fillStyle = '#888';
        vCtx.fillRect(144, 95, 2, 6); // ç°
        
        // å†’çƒŸåŠ¨ç”»
        let smokeY = 90;
        const animateSmoke = () => {
            if (document.getElementById('victory-screen').classList.contains('hidden')) return;
            
            vCtx.fillStyle = '#000'; // æ¸…é™¤çƒŸé›¾åŒºåŸŸ
            vCtx.fillRect(140, 0, 60, 90);
            
            vCtx.fillStyle = 'rgba(200,200,200,0.6)';
            for(let i=0; i<3; i++) {
                const sY = (smokeY - i * 20) % 90;
                const sX = 145 + Math.sin(Date.now()/200 + i)*10;
                if(sY > 0) vCtx.fillRect(sX, sY, 8 + i*2, 8 + i*2);
            }
            smokeY -= 0.5;
            if(smokeY < 0) smokeY = 90;
            
            requestAnimationFrame(animateSmoke);
        };
        animateSmoke();
    }
};

// å¯åŠ¨ç›‘å¬
Input.init();

</script>
</body>
</html>
