<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÁªèÂÖ∏Ê≥°Ê≥°Èæô (Puzzle Bobble)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: #000;
        }

        canvas {
            display: block;
            background: #1a1a1a;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .score-board {
            padding: 10px;
            color: #fff;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 40px;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 3px 3px 0 #e74c3c;
            text-align: center;
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            background: #f1c40f;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            color: #2c3e50;
            font-weight: bold;
            box-shadow: 0 5px 0 #d35400;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 1px 0 #d35400;
        }
        
        #level-indicator {
            color: #3498db;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="640" height="900"></canvas>
    <div id="ui-layer">
        <div class="score-board">
            <span id="score">SCORE: 0</span>
            <span id="level-indicator">LEVEL: 1</span>
        </div>
    </div>
    <div id="message-overlay">
        <h1 id="title-text">PUZZLE BOBBLE</h1>
        <button id="start-btn">START GAME</button>
    </div>
</div>

<script>
/**
 * ÁªèÂÖ∏Ê≥°Ê≥°Èæô (Puzzle Bobble) - Single File Implementation
 */

// --- Constants & Config ---
const CONFIG = {
    GAME_WIDTH: 640,
    GAME_HEIGHT: 900,
    GRID_ROWS: 30, // Max rows
    GRID_COLS: 8,
    BUBBLE_RADIUS: 25, // Diameter 50
    SHOOTER_Y: 820,
    CEILING_DROP_INTERVAL: 8, // Shots before drop
    COLORS: ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#e67e22', '#ecf0f1'],
    SPECIALS: {
        BOMB: 'BOMB',
        RAINBOW: 'RAINBOW',
        STONE: 'STONE'
    }
};

const LEVEL_THEMES = [
    { background: '#1a1a1a', ceiling: '#34495e' },
    { background: '#001826', ceiling: '#0e5c8c' },
    { background: '#1b1300', ceiling: '#d9a441' },
    { background: '#12001f', ceiling: '#7f3fbf' },
    { background: '#210000', ceiling: '#b32020' }
];

const COLOR_ICONS = {
    '#e74c3c': '‚ô•',
    '#3498db': 'üíß',
    '#2ecc71': 'üçÉ',
    '#f1c40f': '‚òÖ',
    '#9b59b6': '‚ô¶',
    '#e67e22': 'üî•',
    '#ecf0f1': '‚ùÑ'
};

// --- Level Designs ---
// Dense format: each char represents a bubble.
// Row 0 (Even): 8 cols
// Row 1 (Odd): 7 cols
const LEVEL_DESIGNS = [
    // Level 1: Simple Pyramid
    [
        "   rr   ", // Row 0 (8): .. r r ..
        "  bbb  ",  // Row 1 (7): . b b b .
        "  gggg  ", // Row 2 (8): . g g g g .
        " yyyyy "   // Row 3 (7): y y y y y
    ],
    // Level 2: Checkerboard
    [
        "rbrbrbrb",
        "brbrbrb",
        "rbrbrbrb",
        "brbrbrb"
    ],
    // Level 3: Stone Wall with Bombs
    [
        "SSSSSSSS",
        " rrBBrr",
        "gggggggg",
        " yySSyy"
    ],
    // Level 4: Rainbow Bridge
    [
        "pppppppp",
        "WWWWWWW",
        "oooooooo",
        "rbgypoc"
    ],
    // Level 5: The Challenge
    [
        "SrSbSgSy",
        "BBBBBBB",
        "rrrrrrrr",
        "SSSSSSS",
        "WWWWWWWW"
    ]
];

// Map characters to types/colors
const CHAR_MAP = {
    'r': '#e74c3c', // Red
    'b': '#3498db', // Blue
    'g': '#2ecc71', // Green
    'y': '#f1c40f', // Yellow
    'p': '#9b59b6', // Purple
    'o': '#e67e22', // Orange
    'c': '#ecf0f1', // Cyan (White-ish)
    'S': { type: 'STONE', color: '#7f8c8d' },
    'B': { type: 'BOMB', color: '#2c3e50' },
    'W': { type: 'RAINBOW', color: 'RAINBOW' }
};

// Calculated Constants
const ROW_HEIGHT = CONFIG.BUBBLE_RADIUS * Math.sqrt(3);
const BUBBLE_DIAMETER = CONFIG.BUBBLE_RADIUS * 2;
// Adjust GRID_COLS logic: Row 0 has 8, Row 1 has 7 (indented)
// Width = 8 * 2r = 16r. 16 * 25 = 400? No, width is 640.
// Let's calculate radius based on width or fix width based on radius.
// Let's fix radius = 320 / 8 = 40.
// 40 is big. 
// If radius is 35 -> 70 diam. 8*70 = 560. Center it.
// Let's use Radius 35.
CONFIG.BUBBLE_RADIUS = 35; 
const GRID_OFFSET_X = (CONFIG.GAME_WIDTH - (CONFIG.GRID_COLS * CONFIG.BUBBLE_RADIUS * 2)) / 2;
// Wait, hex grid packing.
// Row 0: 8 bubbles. Width = 8 * D.
// Row 1: 7 bubbles. Width = 7 * D. Indented by R.
// Total width needed = 8 * D.
const REAL_BUBBLE_DIAMETER = CONFIG.GAME_WIDTH / CONFIG.GRID_COLS; // 640 / 8 = 80
CONFIG.BUBBLE_RADIUS = REAL_BUBBLE_DIAMETER / 2; // 40
const R = CONFIG.BUBBLE_RADIUS;
const D = R * 2;
const HEX_HEIGHT = R * Math.sqrt(3);

// --- Audio System (Web Audio API) ---
class AudioController {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playShoot() { this.playTone(600, 'triangle', 0.15, 0.2); }
    playBounce() { this.playTone(300, 'sine', 0.1, 0.1); }
    playStick() { this.playTone(200, 'square', 0.1, 0.1); }
    playClear() { 
        this.playTone(800, 'sine', 0.1, 0.2); 
        setTimeout(() => this.playTone(1200, 'sine', 0.2, 0.2), 100);
    }
    playDrop() { this.playTone(100, 'sawtooth', 0.3, 0.2); }
    playWin() {
        [400, 500, 600, 800].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.2, 0.2), i * 150));
    }
    playLose() {
        [300, 250, 200, 150].forEach((f, i) => setTimeout(() => this.playTone(f, 'sawtooth', 0.3, 0.2), i * 200));
    }
}

// --- Game Logic ---

class Bubble {
    constructor(row, col, color, type = 'NORMAL') {
        this.row = row;
        this.col = col;
        this.color = color;
        this.type = type; // NORMAL, STONE, BOMB, RAINBOW
        this.x = 0;
        this.y = 0;
        this.animX = 0; // For drop animation
        this.animY = 0;
        this.velocityY = 0; // For drop physics
        this.falling = false;
        this.popping = false;
        this.popTimer = 0;
        this.rainbowHue = 0;
        this.updatePos();
    }

    updatePos() {
        // Calculate screen position from grid position
        // Even row: 0 offset. Odd row: R offset.
        const offsetX = (this.row % 2 === 0) ? 0 : R;
        this.x = this.col * D + R + offsetX;
        this.y = this.row * HEX_HEIGHT + R;
    }

    draw(ctx, ceilingY) {
        if (this.popping) {
            ctx.globalAlpha = this.popTimer / 10;
            ctx.beginPath();
            ctx.arc(this.x, this.y + ceilingY, R * (1 + (10-this.popTimer)/10), 0, Math.PI * 2);
            ctx.fillStyle = this.type === 'RAINBOW' ? `hsl(${this.rainbowHue}, 100%, 50%)` : this.color;
            ctx.fill();
            ctx.globalAlpha = 1.0;
            return;
        }

        let drawY = this.y + ceilingY;
        let drawX = this.x;

        if (this.falling) {
            drawY = this.animY;
            drawX = this.animX;
        }

        if (this.type === 'STONE') {
            const grad = ctx.createRadialGradient(drawX - R/3, drawY - R/3, R/5, drawX, drawY, R);
            grad.addColorStop(0, '#e5e8ea');
            grad.addColorStop(0.4, '#aeb6bf');
            grad.addColorStop(1, '#566573');
            ctx.beginPath();
            ctx.arc(drawX, drawY, R - 3, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(drawX - R * 0.6, drawY - R * 0.2);
            ctx.lineTo(drawX - R * 0.2, drawY + R * 0.1);
            ctx.lineTo(drawX + R * 0.3, drawY - R * 0.3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(drawX - R * 0.1, drawY + R * 0.4);
            ctx.lineTo(drawX + R * 0.4, drawY + R * 0.1);
            ctx.stroke();
            return;
        }

        if (this.type === 'BOMB') {
            const grad = ctx.createRadialGradient(drawX - R/3, drawY - R/3, R/5, drawX, drawY, R);
            grad.addColorStop(0, '#888');
            grad.addColorStop(0.5, '#333');
            grad.addColorStop(1, '#000');
            ctx.beginPath();
            ctx.arc(drawX, drawY, R - 3, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(drawX, drawY, R - 3, -Math.PI * 0.2, Math.PI * 0.3);
            ctx.stroke();
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(drawX, drawY - R);
            ctx.lineTo(drawX + R * 0.4, drawY - R * 1.3);
            ctx.stroke();
            ctx.strokeStyle = '#e67e22';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(drawX + R * 0.4, drawY - R * 1.3);
            ctx.bezierCurveTo(drawX + R * 0.6, drawY - R * 1.5, drawX + R * 0.3, drawY - R * 1.7, drawX + R * 0.1, drawY - R * 1.4);
            ctx.stroke();
            return;
        }

        if (this.type === 'RAINBOW') {
            this.rainbowHue = (this.rainbowHue + 2) % 360;
            const grad = ctx.createRadialGradient(drawX - R/3, drawY - R/3, R/5, drawX, drawY, R);
            grad.addColorStop(0, `hsl(${this.rainbowHue}, 100%, 85%)`);
            grad.addColorStop(0.4, `hsl(${(this.rainbowHue + 60) % 360}, 100%, 60%)`);
            grad.addColorStop(0.8, `hsl(${(this.rainbowHue + 180) % 360}, 100%, 55%)`);
            grad.addColorStop(1, `hsl(${(this.rainbowHue + 260) % 360}, 100%, 50%)`);
            ctx.beginPath();
            ctx.arc(drawX, drawY, R - 3, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(drawX, drawY, R - 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚òÖ', drawX, drawY);
            return;
        }

        const baseGrad = ctx.createRadialGradient(drawX - R/3, drawY - R/3, R/5, drawX, drawY, R);
        baseGrad.addColorStop(0, adjustColor(this.color, 60));
        baseGrad.addColorStop(0.5, adjustColor(this.color, 20));
        baseGrad.addColorStop(1, this.color);
        ctx.beginPath();
        ctx.arc(drawX, drawY, R - 3, 0, Math.PI * 2);
        ctx.fillStyle = baseGrad;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(drawX - R/3, drawY - R/3, R/4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(drawX, drawY, R - 3, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 2;
        ctx.stroke();
        const icon = COLOR_ICONS[this.color];
        if (icon) {
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = R + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(icon, drawX, drawY + R * 0.05);
        }
    }
}

class Projectile {
    constructor(x, y, angle, color, type = 'NORMAL') {
        this.x = x;
        this.y = y;
        this.color = color;
        this.type = type;
        this.speed = 25; // Fast speed
        this.angle = angle;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.radius = R;
        this.active = true;
        this.rainbowHue = 0;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        // Wall Bounce
        if (this.x - this.radius < 0) {
            this.x = this.radius;
            this.vx = -this.vx;
            return true; // Bounced
        }
        if (this.x + this.radius > CONFIG.GAME_WIDTH) {
            this.x = CONFIG.GAME_WIDTH - this.radius;
            this.vx = -this.vx;
            return true; // Bounced
        }
        return false;
    }

    draw(ctx) {
        if (this.type === 'RAINBOW') {
            this.rainbowHue = (this.rainbowHue + 5) % 360;
            const grad = ctx.createRadialGradient(this.x - R/3, this.y - R/3, R/5, this.x, this.y, R);
            grad.addColorStop(0, `hsl(${this.rainbowHue}, 100%, 80%)`);
            grad.addColorStop(1, `hsl(${this.rainbowHue}, 100%, 50%)`);
            ctx.beginPath();
            ctx.arc(this.x, this.y, R - 2, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            return;
        }

        if (this.type === 'BOMB') {
             const grad = ctx.createRadialGradient(this.x - R/3, this.y - R/3, R/5, this.x, this.y, R);
            grad.addColorStop(0, '#555');
            grad.addColorStop(1, '#000');
            ctx.beginPath();
            ctx.arc(this.x, this.y, R - 2, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.fillStyle = '#e74c3c';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üí£', this.x, this.y);
            return;
        }
        
        const grad = ctx.createRadialGradient(this.x - R/3, this.y - R/3, R/5, this.x, this.y, R);
        grad.addColorStop(0, adjustColor(this.color, 40));
        grad.addColorStop(1, this.color);
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, R - 2, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.beginPath();
        ctx.arc(this.x - R/3, this.y - R/3, R/4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 1.0;
        this.color = color;
        this.size = Math.random() * 5 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
        this.vy += 0.5; // Gravity
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new AudioController();
        
        this.score = 0;
        this.level = 1;
        this.state = 'MENU'; // MENU, PLAYING, GAMEOVER, VICTORY
        
        this.grid = []; // 2D array of Bubbles or null
        this.ceilingOffset = 0; // Pixels the ceiling has dropped
        this.shotsFired = 0;
        
        this.projectile = null;
        this.nextBubbleColor = null;
        this.currentBubbleColor = null;
        
        this.mouseX = CONFIG.GAME_WIDTH / 2;
        this.mouseY = CONFIG.GAME_HEIGHT / 2;
        
        this.particles = [];
        this.fallingBubbles = []; // Bubbles that are dropping
        
        this.bindEvents();
        this.loadLevel(1);
        
        // Start loop
        requestAnimationFrame(() => this.loop());
    }

    bindEvents() {
        this.canvas.addEventListener('mousemove', e => {
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            this.mouseX = (e.clientX - rect.left) * scaleX;
            this.mouseY = (e.clientY - rect.top) * scaleY;
        });

        this.canvas.addEventListener('click', () => this.shoot());
        
        // Touch support
        this.canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            this.mouseX = (e.touches[0].clientX - rect.left) * scaleX;
            this.mouseY = (e.touches[0].clientY - rect.top) * scaleY;
        }, {passive: false});
        
        this.canvas.addEventListener('touchstart', (e) => {
             e.preventDefault();
             // Just update aim
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            this.mouseX = (e.touches[0].clientX - rect.left) * scaleX;
            this.mouseY = (e.touches[0].clientY - rect.top) * scaleY;
        }, {passive: false});

        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.shoot();
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            if (this.audio.ctx.state === 'suspended') this.audio.ctx.resume();
            this.startGame();
        });
    }

    startGame() {
        document.getElementById('message-overlay').classList.add('hidden');
        this.state = 'PLAYING';
        this.resetGame();
    }

    resetGame() {
        this.score = 0;
        this.level = 1;
        this.loadLevel(this.level);
    }

    loadLevel(level) {
        this.grid = [];
        this.shotsFired = 0;
        this.ceilingOffset = 0;
        this.fallingBubbles = [];
        this.particles = [];
        this.projectile = null;
        this.score = 0; // Reset score per level? Or Keep? Arcade usually keeps.
        // Let's keep score but maybe reset if Game Over.
        
        // Load Design
        const designIndex = (level - 1) % LEVEL_DESIGNS.length;
        const design = LEVEL_DESIGNS[designIndex];

        for (let r = 0; r < CONFIG.GRID_ROWS; r++) {
            this.grid[r] = [];
            for (let c = 0; c < CONFIG.GRID_COLS; c++) {
                // Handle odd row length (7 cols)
                if (r % 2 !== 0 && c >= CONFIG.GRID_COLS - 1) continue;

                if (r < design.length) {
                    const rowStr = design[r];
                    // Dense string parsing: direct index map
                    // Row 0 (Even): length 8. c goes 0..7
                    // Row 1 (Odd): length 7. c goes 0..6
                    // If rowStr is shorter, treat as space.
                    
                    const char = rowStr[c] || ' ';
                    
                    if (char !== ' ' && CHAR_MAP[char]) {
                        const mapVal = CHAR_MAP[char];
                        let color, type;
                        if (typeof mapVal === 'string') {
                            color = mapVal;
                            type = 'NORMAL';
                        } else {
                            color = mapVal.color;
                            type = mapVal.type;
                        }
                        this.grid[r][c] = new Bubble(r, c, color, type);
                    } else {
                         this.grid[r][c] = null;
                    }
                } else {
                    this.grid[r][c] = null;
                }
            }
        }
        
        this.reloadLauncher();
        this.updateUI();
    }

    getAvailableColors() {
        const colors = new Set();
        for(let r=0; r<this.grid.length; r++) {
            for(let c=0; c<this.grid[r].length; c++) {
                if(this.grid[r][c] && this.grid[r][c].type === 'NORMAL') {
                    colors.add(this.grid[r][c].color);
                }
            }
        }
        // If only stones/specials left, give random basic color
        if (colors.size === 0) {
             return CONFIG.COLORS.slice(0, 3);
        }
        return Array.from(colors);
    }

    reloadLauncher() {
        const available = this.getAvailableColors();
        
        // Chance for Special Bubble in Launcher?
        // Let's say 10% chance if level > 2
        const giveSpecial = (this.level > 1 && Math.random() < 0.1);
        
        const getRandom = () => {
            if (giveSpecial) {
                const r = Math.random();
                if (r < 0.4) return { color: CHAR_MAP['B'].color, type: 'BOMB' };
                if (r < 0.7) return { color: CHAR_MAP['W'].color, type: 'RAINBOW' };
                // Stones are not shot usually.
            }
            return { color: available[Math.floor(Math.random() * available.length)], type: 'NORMAL' };
        };

        if (!this.nextBubbleColor) {
            this.nextBubbleColor = getRandom();
        }
        
        if (!this.currentBubbleColor) {
             this.currentBubbleColor = getRandom();
        } else {
            this.currentBubbleColor = this.nextBubbleColor;
            this.nextBubbleColor = getRandom();
        }
    }

    shoot() {
        if (this.state !== 'PLAYING' || this.projectile) return;
        
        const angle = Math.atan2(this.mouseY - CONFIG.SHOOTER_Y, this.mouseX - CONFIG.GAME_WIDTH/2);
        if (angle > -0.2) return; 
        if (angle < -Math.PI + 0.2) return; 

        this.projectile = new Projectile(CONFIG.GAME_WIDTH/2, CONFIG.SHOOTER_Y, angle, this.currentBubbleColor.color, this.currentBubbleColor.type);
        this.audio.playShoot();
        
        this.shotsFired++;
        if (this.shotsFired % CONFIG.CEILING_DROP_INTERVAL === 0) {
            this.pendingDrop = true;
        }
    }

    update() {
        if (this.state !== 'PLAYING') return;

        // Update Projectile
        if (this.projectile) {
            const bounced = this.projectile.update();
            if(bounced) this.audio.playBounce();
            
            // Ceiling Collision
            // The ceiling is at y = 0 initially, but effectively at y = -ceilingOffset
            // Actually, we render bubbles at y + ceilingOffset.
            // So logical y = 0 is rendered at ceilingOffset.
            // If projectile.y - radius < ceilingOffset -> Hit ceiling
            // Wait, grid[0] is at y=R. Drawn at R + ceilingOffset.
            // Top wall is at y = ceilingOffset (visually).
            // Actually, let's treat ceilingOffset as a shift in GRID coordinates or visual?
            // Let's treat it as visual shift. Logical grid stays.
            // But if ceiling drops, it pushes bubbles down.
            // Collision check: Projectile Y vs Bubble Y (which includes offset).
            
            // Check Ceiling (Top Wall)
            if (this.projectile.y - this.projectile.radius <= this.ceilingOffset) {
                this.snapProjectile();
            } else {
                // Check Bubble Collision
                let hit = false;
                for (let r = 0; r < this.grid.length; r++) {
                    for (let c = 0; c < this.grid[r].length; c++) {
                        const b = this.grid[r][c];
                        if (b && !b.falling && !b.popping) {
                            const dx = this.projectile.x - b.x;
                            const dy = this.projectile.y - (b.y + this.ceilingOffset);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < D * 0.85) { // Slightly smaller than diameter for feel
                                hit = true;
                                break;
                            }
                        }
                    }
                    if (hit) break;
                }
                if (hit) this.snapProjectile();
            }
        }

        // Update Falling Bubbles
        for (let i = this.fallingBubbles.length - 1; i >= 0; i--) {
            const b = this.fallingBubbles[i];
            b.animY += b.velocityY;
            b.velocityY += 1.5; // Gravity
            b.animX += (Math.random() - 0.5) * 2; // Flutter
            
            if (b.animY > CONFIG.GAME_HEIGHT) {
                this.fallingBubbles.splice(i, 1);
            }
        }

        // Update Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }
    }

    snapProjectile() {
        if (!this.projectile) return;
        
        // Find best grid position
        const py = this.projectile.y - this.ceilingOffset;
        const px = this.projectile.x;
        
        let bestRow = Math.round((py - R) / HEX_HEIGHT);
        if (bestRow < 0) bestRow = 0;
        if (bestRow >= CONFIG.GRID_ROWS) bestRow = CONFIG.GRID_ROWS - 1;
        
        const isOdd = bestRow % 2 !== 0;
        const offsetX = isOdd ? R : 0;
        let bestCol = Math.round((px - R - offsetX) / D);
        
        const maxCol = isOdd ? CONFIG.GRID_COLS - 2 : CONFIG.GRID_COLS - 1;
        if (bestCol < 0) bestCol = 0;
        if (bestCol > maxCol) bestCol = maxCol;

        // Occupied check / Neighbor search logic (Simplified for brevity, same as before)
        if (this.grid[bestRow][bestCol]) {
             const neighbors = this.getNeighbors(bestRow, bestCol);
             let minDist = Infinity;
             let target = null;
             for(let r=0; r<this.grid.length; r++) {
                 for(let c=0; c<this.grid[r].length; c++) {
                     if (!this.grid[r][c]) {
                         if(r%2!==0 && c===CONFIG.GRID_COLS-1) continue;
                         const offsetX = (r % 2 === 0) ? 0 : R;
                         const bx = c * D + R + offsetX;
                         const by = r * HEX_HEIGHT + R + this.ceilingOffset;
                         const dist = Math.sqrt((px-bx)**2 + (py+this.ceilingOffset-by)**2);
                         if (dist < D * 2) {
                             if (dist < minDist) {
                                 minDist = dist;
                                 target = {r, c};
                             }
                         }
                     }
                 }
             }
             if(target) {
                 bestRow = target.r;
                 bestCol = target.c;
             }
        }

        // Place bubble
        const newBubble = new Bubble(bestRow, bestCol, this.projectile.color, this.projectile.type);
        this.grid[bestRow][bestCol] = newBubble;
        this.projectile = null;
        this.audio.playStick();

        // Process Matches based on Type
        if (newBubble.type === 'BOMB') {
            this.processBomb(newBubble);
        } else {
            this.processMatches(newBubble);
        }
        
        this.reloadLauncher();
        this.checkLoss();
        this.checkWin(); // Check win condition (clear all normal bubbles)

        if (this.pendingDrop) {
            this.dropCeiling();
            this.pendingDrop = false;
        }
    }

    processBomb(bomb) {
        // Explode neighbors + self
        const neighbors = this.getNeighbors(bomb.row, bomb.col);
        neighbors.push({r: bomb.row, c: bomb.col}); // Add self
        
        neighbors.forEach(n => {
            const b = this.grid[n.r][n.c];
            if (b && !b.falling) {
                this.grid[n.r][n.c] = null;
                this.createExplosion(b.x, b.y + this.ceilingOffset, b.color);
                this.score += 50;
            }
        });
        
        this.audio.playClear();
        this.updateUI();
        this.dropFloatingClusters();
    }

    processMatches(startBubble) {
        // Special Logic for Rainbow
        // If Rainbow, it matches the color of the first valid neighbor it touched?
        // Actually, Rainbow matches *any* color group it touches.
        // Simplified: Treat Rainbow as "Wildcard" in BFS? 
        // Or transform Rainbow to a color?
        // Let's transform Rainbow to the color of a neighbor for stability.
        
        if (startBubble.type === 'RAINBOW') {
            const neighbors = this.getNeighbors(startBubble.row, startBubble.col);
            let targetColor = null;
            // Find a colored neighbor
            for(let n of neighbors) {
                const b = this.grid[n.r][n.c];
                if (b && b.type === 'NORMAL') {
                    targetColor = b.color;
                    break;
                }
            }
            if (targetColor) {
                startBubble.type = 'NORMAL';
                startBubble.color = targetColor;
            } else {
                // No neighbor? It stays Rainbow (useless until hit) or pops?
                // Just leave it.
                return; 
            }
        }

        if (startBubble.type === 'STONE') return; // Stones don't match

        const matchSet = new Set();
        const queue = [startBubble];
        matchSet.add(startBubble);
        const color = startBubble.color;

        let head = 0;
        while(head < queue.length) {
            const current = queue[head++];
            const neighbors = this.getNeighbors(current.row, current.col);
            for(let n of neighbors) {
                const b = this.grid[n.r][n.c];
                // Match condition: Same Color OR Rainbow
                // Note: We already converted Rainbow to Normal above, so just check color.
                if (b && !matchSet.has(b) && !b.falling && !b.popping) {
                    if (b.type === 'NORMAL' && b.color === color) {
                        matchSet.add(b);
                        queue.push(b);
                    }
                }
            }
        }

        if (matchSet.size >= 3) {
            matchSet.forEach(b => {
                this.grid[b.row][b.col] = null;
                this.createExplosion(b.x, b.y + this.ceilingOffset, b.color);
                this.score += 10;
            });
            this.audio.playClear();
            this.updateUI();
            this.dropFloatingClusters();
        }
    }

    checkWin() {
        // Win if no NORMAL bubbles left? Or no bubbles at all?
        // Usually "Clear the screen".
        let hasBubbles = false;
        for(let r=0; r<this.grid.length; r++) {
            for(let c=0; c<this.grid[r].length; c++) {
                if (this.grid[r][c] && this.grid[r][c].type !== 'STONE') {
                    hasBubbles = true;
                    break;
                }
            }
            if (hasBubbles) break;
        }
        if (!hasBubbles) {
            this.winLevel();
        }
    }

    updateUI() {
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level-indicator');
        if (scoreEl) scoreEl.textContent = 'SCORE: ' + this.score;
        if (levelEl) levelEl.textContent = 'LEVEL: ' + this.level;
    }

    getNeighbors(row, col) {
        const neighbors = [];
        const isOdd = row % 2 !== 0;
        const deltas = isOdd
            ? [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]]
            : [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]];

        for (const [dr, dc] of deltas) {
            const nr = row + dr;
            const nc = col + dc;
            if (nr < 0 || nr >= CONFIG.GRID_ROWS) continue;
            if (nc < 0 || nc >= CONFIG.GRID_COLS) continue;
            if (nr % 2 !== 0 && nc === CONFIG.GRID_COLS - 1) continue;
            neighbors.push({ r: nr, c: nc });
        }
        return neighbors;
    }

    dropFloatingClusters() {
        const visited = new Set();
        const queue = [];

        const enqueue = (r, c) => {
            const key = r + ',' + c;
            if (visited.has(key)) return;
            visited.add(key);
            queue.push({ r, c });
        };

        if (this.grid.length > 0) {
            for (let c = 0; c < this.grid[0].length; c++) {
                const b = this.grid[0][c];
                if (b && !b.falling && !b.popping) {
                    enqueue(0, c);
                }
            }
        }

        while (queue.length > 0) {
            const cell = queue.shift();
            const neighbors = this.getNeighbors(cell.r, cell.c);
            for (const n of neighbors) {
                const b = this.grid[n.r][n.c];
                if (b && !b.falling && !b.popping) {
                    enqueue(n.r, n.c);
                }
            }
        }

        let dropped = 0;
        for (let r = 0; r < this.grid.length; r++) {
            for (let c = 0; c < this.grid[r].length; c++) {
                const b = this.grid[r][c];
                if (!b || b.falling || b.popping) continue;
                const key = r + ',' + c;
                if (!visited.has(key)) {
                    this.grid[r][c] = null;
                    b.falling = true;
                    b.animX = b.x;
                    b.animY = b.y + this.ceilingOffset;
                    b.velocityY = 0;
                    this.fallingBubbles.push(b);
                    this.score += 5;
                    dropped++;
                }
            }
        }

        if (dropped > 0) {
            this.audio.playDrop();
            this.updateUI();
        }
    }

    dropCeiling() {
        this.ceilingOffset += HEX_HEIGHT / 2;
        this.audio.playDrop();
        this.checkLoss();
    }

    createExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    checkLoss() {
        for (let r = 0; r < this.grid.length; r++) {
            for (let c = 0; c < this.grid[r].length; c++) {
                const b = this.grid[r][c];
                if (!b || b.falling || b.popping) continue;
                const screenY = b.y + this.ceilingOffset;
                if (screenY + R >= CONFIG.SHOOTER_Y) {
                    this.state = 'GAMEOVER';
                    this.audio.playLose();
                    const overlay = document.getElementById('message-overlay');
                    const title = document.getElementById('title-text');
                    const btn = document.getElementById('start-btn');
                    if (overlay) overlay.classList.remove('hidden');
                    if (title) title.textContent = 'GAME OVER';
                    if (btn) btn.textContent = 'RESTART';
                    return;
                }
            }
        }
    }

    winLevel() {
        this.audio.playWin();
        this.level++;
        this.loadLevel(this.level);
        this.state = 'PLAYING';
        this.updateUI();
    }

    draw() {
        this.ctx.clearRect(0, 0, CONFIG.GAME_WIDTH, CONFIG.GAME_HEIGHT);
        const theme = LEVEL_THEMES[(this.level - 1) % LEVEL_THEMES.length];
        const bg = this.ctx.createLinearGradient(0, 0, 0, CONFIG.GAME_HEIGHT);
        bg.addColorStop(0, theme.background);
        bg.addColorStop(1, '#000000');
        this.ctx.fillStyle = bg;
        this.ctx.fillRect(0, 0, CONFIG.GAME_WIDTH, CONFIG.GAME_HEIGHT);

        this.ctx.fillStyle = theme.ceiling;
        this.ctx.fillRect(0, this.ceilingOffset, CONFIG.GAME_WIDTH, 4);

        for (let r = 0; r < this.grid.length; r++) {
            for (let c = 0; c < this.grid[r].length; c++) {
                const b = this.grid[r][c];
                if (b) b.draw(this.ctx, this.ceilingOffset);
            }
        }

        for (const b of this.fallingBubbles) {
            b.draw(this.ctx, 0);
        }

        if (this.projectile) {
            this.projectile.draw(this.ctx);
        }

        if (this.state === 'PLAYING' && !this.projectile) {
            this.drawAimLine();
        }

        for (const p of this.particles) {
            p.draw(this.ctx);
        }

        this.drawShooter();
    }

    drawAimLine() {
        const startX = CONFIG.GAME_WIDTH / 2;
        const startY = CONFIG.SHOOTER_Y;
        const angle = Math.atan2(this.mouseY - startY, this.mouseX - startX);
        
        if (angle > -0.2 && angle < Math.PI) return;

        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]);
        
        this.ctx.beginPath();
        this.ctx.moveTo(startX, startY);
        
        // Realistic Simulation
        let simX = startX;
        let simY = startY;
        let simVx = Math.cos(angle) * 10; // Use smaller steps for accuracy or just direction
        let simVy = Math.sin(angle) * 10;
        
        // Normalize vector to step size
        const step = 5; 
        simVx = Math.cos(angle) * step;
        simVy = Math.sin(angle) * step;
        
        const maxSteps = 400; // Limit length
        
        for(let i=0; i<maxSteps; i++) {
            simX += simVx;
            simY += simVy;
            
            // Wall Bounce
            if (simX < R || simX > CONFIG.GAME_WIDTH - R) {
                simVx = -simVx;
                simX += simVx; // Push back
                this.ctx.lineTo(simX, simY); // Draw corner
            }
            
            // Ceiling
            if (simY <= this.ceilingOffset + R) {
                this.ctx.lineTo(simX, simY);
                // Draw circle at impact
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.arc(simX, simY, R, 0, Math.PI*2);
                this.ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                this.ctx.setLineDash([]);
                this.ctx.stroke();
                return;
            }
            
            // Bubble Collision
            // Check against all bubbles? Expensive?
            // Optimization: Map simX/simY to grid and check neighbors
            // For aim line, we can just check distance to bubbles roughly.
            
            let hit = false;
            // Only check if we are high enough to hit something
            if (simY < CONFIG.GAME_HEIGHT) { // Always check
                 // Quick check: Find grid cell for simX, simY
                 // If that cell or neighbors occupied -> collision test
                 // ... Implementing full grid check for every step is heavy.
                 // Let's just check raw distance to *any* bubble if y is low enough
                 
                 // Optimization: Only check bubbles in rows near simY
                 const approxRow = Math.floor((simY - this.ceilingOffset - R) / HEX_HEIGHT);
                 if (approxRow >= 0 && approxRow < CONFIG.GRID_ROWS) {
                     // Check this row and +/- 1
                     for (let r = Math.max(0, approxRow-1); r <= Math.min(CONFIG.GRID_ROWS-1, approxRow+1); r++) {
                         for (let c = 0; c < this.grid[r].length; c++) {
                             const b = this.grid[r][c];
                             if (b && !b.falling) {
                                 const dx = simX - b.x;
                                 const dy = simY - (b.y + this.ceilingOffset);
                                 if (dx*dx + dy*dy < (D * 0.9)**2) { // Hit
                                     hit = true;
                                     break;
                                 }
                             }
                         }
                         if(hit) break;
                     }
                 }
            }
            
            if (hit) {
                this.ctx.lineTo(simX, simY);
                this.ctx.stroke();
                
                // Draw Ghost Bubble
                this.ctx.beginPath();
                this.ctx.arc(simX, simY, R, 0, Math.PI*2);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.fill();
                return;
            }
        }
        
        this.ctx.lineTo(simX, simY);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    }

    drawShooter() {
        const x = CONFIG.GAME_WIDTH / 2;
        const y = CONFIG.SHOOTER_Y;
        
        // Current Bubble
        if (this.currentBubbleColor) {
            // Fix: currentBubbleColor is now an object {color, type}
            const color = this.currentBubbleColor.color || CONFIG.COLORS[0];
            const type = this.currentBubbleColor.type || 'NORMAL';
            const b = new Bubble(0,0, color, type); 
            b.x = x;
            b.y = y;
            b.draw(this.ctx, 0);
        }

        // Next Bubble (Small indicator)
        if (this.nextBubbleColor) {
            const bx = x - D * 1.5;
            const by = y + R;
            
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '14px Arial';
            this.ctx.fillText('NEXT', bx - 15, by - R - 5);
            
            // Fix: nextBubbleColor is an object
            const nextColor = this.nextBubbleColor.color || CONFIG.COLORS[0];
            const nextType = this.nextBubbleColor.type || 'NORMAL';

            if (nextType === 'RAINBOW') {
                 // Simple Rainbow indicator
                 const grad = this.ctx.createRadialGradient(bx - R/4, by - R/4, R/8, bx, by, R/1.5);
                 grad.addColorStop(0, `hsl(${Date.now() / 10 % 360}, 100%, 80%)`);
                 grad.addColorStop(1, `hsl(${Date.now() / 10 % 360}, 100%, 50%)`);
                 this.ctx.beginPath();
                 this.ctx.arc(bx, by, R/1.5, 0, Math.PI*2);
                 this.ctx.fillStyle = grad;
                 this.ctx.fill();
            } else if (nextType === 'BOMB') {
                 // Bomb indicator
                 const grad = this.ctx.createRadialGradient(bx - R/4, by - R/4, R/8, bx, by, R/1.5);
                 grad.addColorStop(0, '#555');
                 grad.addColorStop(1, '#000');
                 this.ctx.beginPath();
                 this.ctx.arc(bx, by, R/1.5, 0, Math.PI*2);
                 this.ctx.fillStyle = grad;
                 this.ctx.fill();
                 this.ctx.fillStyle = '#e74c3c';
                 this.ctx.font = '16px Arial';
                 this.ctx.fillText('üí£', bx, by);
            } else {
                // Normal
                const grad = this.ctx.createRadialGradient(bx - R/4, by - R/4, R/8, bx, by, R/1.5);
                grad.addColorStop(0, adjustColor(nextColor, 40));
                grad.addColorStop(1, nextColor);
                this.ctx.beginPath();
                this.ctx.arc(bx, by, R/1.5, 0, Math.PI*2);
                this.ctx.fillStyle = grad;
                this.ctx.fill();
            }
        }
        
        // Arrow/Launcher graphic
        this.ctx.save();
        this.ctx.translate(x, y);
        const angle = Math.atan2(this.mouseY - y, this.mouseX - x);
        this.ctx.rotate(angle);
        
        this.ctx.fillStyle = '#95a5a6';
        this.ctx.fillRect(0, -5, 60, 10);
        this.ctx.beginPath();
        this.ctx.moveTo(60, -10);
        this.ctx.lineTo(80, 0);
        this.ctx.lineTo(60, 10);
        this.ctx.fill();
        
        this.ctx.restore();
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// Helper: Lighten/Darken color
function adjustColor(color, amount) {
    let usePound = false;
    if (color[0] == "#") {
        color = color.slice(1);
        usePound = true;
    }
    let num = parseInt(color, 16);
    let r = (num >> 16) + amount;
    if (r > 255) r = 255; else if (r < 0) r = 0;
    let b = ((num >> 8) & 0x00FF) + amount;
    if (b > 255) b = 255; else if (b < 0) b = 0;
    let g = (num & 0x0000FF) + amount;
    if (g > 255) g = 255; else if (g < 0) g = 0;
    return (usePound?"#":"") + (g | (b << 8) | (r << 16)).toString(16);
}

// Init
window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>
